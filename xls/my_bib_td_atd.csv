,year,title,abstract
3,0,Managing Technical Debt in XP Teams,
5,0,Challenges in Explaining Source Code Quality Assessment,
6,0,Architectural Technical Debt-can it be prevented with a software project generator?,"Architectural Technical Debt (ATD) is a challenge that many of today’s companies aim to overcome. ATD concerns the overall structure and architecture of a softwareintensive system and can be described as the unresolved shortcuts developers take under circumstances of e.g. time pressure and uncertain requirements. Planning and constructing a well-thought-out architecture is time consuming and resource-intensive and if not done carefully, it can cause ATD. This thesis aims to investigate if it is possible to prevent the rise of ATD with a software project generator and how to maintain it. We have carried out a study following the design science research paradigm at a case company, Jayway by Devoteam. We conducted both literature and empirical studies to better understand the current situation at the case company and based on that proposed a feasible solution. According to our findings, a project generator tool can mitigate the causes of ATD at the beginning of a project. However, ATD can be introduced later on due to various factors, for instance negligence of best practices. Moreover, we concluded that the most suitable way for maintaining such a tool is adopting Inner Source."
7,0,A Survey of Software Architectural Change Detection and Categorization Techniques,
8,1974,The mythical man-month,"The more complex is a problem, it does not always put more people to help solve the problem."
9,1982,Robust tests for heteroscedasticity based on regression quantiles,
10,1986,"Influential observations, high leverage points, and outliers in linear regression",
12,1992,Foundations for the study of software architecture,"The purpose of this paper is to build the foundation for software architecture. We first develop an intuition for software architecture by appealing to several well-established architectural disciplines. On the basis of this intuition, we present a model of software architecture that consists of three components: elements, form, and rationale. Elements are either processing, data, or connecting elements. Form is defined in terms of the properties of, and the relationships among, the elements --- that is, the constraints on the elements. The rationale provides the underlying basis for the architecture in terms of the system constraints, which most often derive from the system requirements. We discuss the components of the model in the context of both architectures and architectural styles and present an extended example to illustrate some important architecture and style considerations. We conclude by presenting some of the benefits of our approach to software architecture, summarizing our contributions, and relating our approach to other current work."
11,1992,The WyCash Portfolio Management System,
13,1994,A Metrics Suite for Object Oriented Design,"Given the central role that software development plays in the delivery and application of information technology, managers are increasingly focusing on process improvement in the software development area. This demand has spurred the provision of a number of new and/or improved approaches to software development, with perhaps the most prominent being object-orientation (OO). In addition, the focus on process improvement has increased the demand for software measures, or metrics with which to manage the process. The need for such metrics is particularly acute when an organization is adopting a new technology for which established practices have yet to be developed. This research addresses these needs through the development and implementation of a new suite of metrics for OO design. Metrics developed in previous research, while contributing to the field's understanding of software development processes, have generally been subject to serious criticisms, including the lack of a theoretical base. Following Wand and Weber (1989), the theoretical base chosen for the metrics was the ontology of Bunge (1977). Six design metrics are developed, and then analytically evaluated against Weyuker's (1988) proposed set of measurement principles. An automated data collection tool was then developed and implemented to collect an empirical sample of these metrics at two field sites in order to demonstrate their feasibility and suggest ways in which managers may use these metrics for process improvement."
14,1995,Management of distributed concurrent development for large scale software systems,"The article discusses a new software process model, distributed concurrent development, and its experience in developing a family of large-scale communication software systems. We have experienced an evolutionary change of our software development process. The change is spread into two dimensions, that is, from sequential to concurrent, and from centralized to distributed. With the concurrent development process model, multiple functions to a single software system are concurrently developed from the beginning of the development process, i.e. requirement specification, to system testing. In the distributed development process model, the development organization is decentralized into multiple development sites which are geographically distributed. The two dimensional changes require a fundamental re-think of our software process and brought about a significant impact on every aspect of software development activities ranging from individual developers to the entire project. We discuss the model, the issues in implementing the model, and our total system of managing the process, project and products."
15,1996,A validation of object-oriented design metrics as quality indicators,"This paper presents the results of a study in which we empirically investigated the suite of object-oriented (OO) design metrics introduced in (Chidamber and Kemerer, 1994). More specifically, our goal is to assess these metrics as predictors of fault-prone classes and, therefore, determine whether they can be used as early quality indicators. This study is complementary to the work described in (Li and Henry, 1993) where the same suite of metrics had been used to assess frequencies of maintenance changes to classes. To perform our validation accurately, we collected data on the development of eight medium-sized information management systems based on identical requirements. All eight projects were developed using a sequential life cycle model, a well-known OO analysis/design method and the C++ programming language. Based on empirical and quantitative analysis, the advantages and drawbacks of these OO metrics are discussed. Several of Chidamber and Kemerer's OO metrics appear to be useful to predict class fault-proneness during the early phases of the life-cycle. Also, on our data set, they are better predictors than ""traditional"" code metrics, which can only be collected at a later phase of the software development processes."
16,1996,Laws of software evolution revisited,"Data obtained during a 1968 study of the software process [8] led to an investigation of the evolution of OS/360 [13] and and, over a period of twenty years, to formulation of eight Laws of Software Evolution. The FEAST project recently initiated (see sections 4–6 below) is expected to throw additional light on the phenomenology underlying these laws, to increase understanding of them, to explore their finer detail, to expose their wider relevance and implications and to develop means for their beneficial exploitation. This paper is intended to trigger wider interest in the laws and in the FEAST study of feedback and feedback control in the context of the software process and its improvement to ensure beneficial exploitation of their potential"
17,1997,"Content analysis: concepts, methods and applications.",
18,2000,"Effects of Process Maturity on Quality, Cycle Time, and Effort in Software Product Development","The information technology (IT) industry is characterized by rapid innovation and intense competition. To survive, IT firms must develop high quality software products on time and at low cost. A key issue is whether high levels of quality can be achieved without adversely impacting cycle time and effort. Conventional beliefs hold that processes to improve software quality can be implemented only at the expense of longer cycle times and greater development effort. However, an alternate view is that quality improvement, faster cycle time, and effort reduction can be simultaneously attained by reducing defects and rework. In this study, we empirically investigate the relationship between process maturity, quality, cycle time, and effort for the development of 30 software products by a major IT firm. We find that higher levels of process maturity as assessed by the Software Engineering Institute's Capability Maturity Model™ are associated with higher product quality, but also with increases in development effort. However, our findings indicate that the reductions in cycle time and effort due to improved quality outweigh the increases from achieving higher levels of process maturity. Thus, the net effect of process maturity is reduced cycle time and development effort."
19,2001,Tactical Approaches for Alleviating Distance in Global Software Development,"To overcome the problem of distance in global software development, various managers are experimenting and quickly adjusting their tactical approaches. We discuss some emerging approaches and explain their motivations from conceptual and practical perspectives. The most intuitive approach for alleviating distance is to apply communication technologies, but this is not our focus. Rather, we examine tactics that go beyond communication technologies, tactics aimed at reducing intensive collaboration, national and organizational cultural differences, and temporal distance."
20,2003,Software architecture in practice,
21,2003,An empirical study of speed and communication in globally distributed software development,"Global software development is rapidly becoming the norm for technology companies. Previous qualitative research suggests that distributed development may increase development cycle time for individual work items (modification requests). We use both data from the source code change management system and survey data to model the extent of delay in a distributed software development organization and explore several possible mechanisms for this delay. One key finding is that distributed work items appear to take about two and one-half times as long to complete as similar items where all the work is colocated. The data strongly suggest a mechanism for the delay, i.e., that distributed work items involve more people than comparable same-site work items, and the number of people involved is strongly related to the calendar time to complete a work item. We replicate the analysis of change data in a different organization with a different product and different sites and confirm our main findings. We also report survey results showing differences between same-site and distributed social networks, testing several hypotheses about characteristics of distributed social networks that may be related to delay. We discuss implications of our findings for practices and collaboration technology that have the potential for dramatically speeding distributed software development."
23,2004,Refactoring to Patterns,
22,2004,"Systematic reviews and meta-analyses: an illustrated, step-by-step guide.","Systematic reviews and meta-analyses synthesize data from existing primary research, and well-conducted reviews offer clinicians a practical solution to the problem of staying current in their fields of interest. A whole generation of secondary journals, pre-appraised evidence libraries and periodically updated electronic texts are now available to clinicians. However, not all systematic reviews are of high quality, and it is important to be able to critically assess their validity and applicability. This article is an illustrated guide for conducting systematic reviews. A clear understanding of the process will provide clinicians with the tools to judiciously appraise reviews and interpret them. We hope that it will enable clinicians to conduct systematic reviews, generate high-quality evidence, and contribute to the evidence-based medicine movement."
24,2005,Practical machine learning tools and techniques,
25,2006,Requirements engineering paper classification and evaluation criteria: a proposal and a discussion,"In recent years, members of the steering committee of the IEEE Requirements Engineering (RE) Conference have discussed paper classification and evaluation criteria for RE papers. The immediate trigger for this discussion was our concern about differences in opinion that sometimes arise in program committees about the criteria to be used in evaluating papers. If program committee members do not all use the same criteria, or if they use criteria different from those used by authors, then papers might be rejected or accepted for the wrong reasons. Surely not all papers should be evaluated according to the same criteria. Some papers describe new techniques but do not report on empirical research; others describe new conceptual frameworks for investigating certain RE problems; others report on industrial experience with existing RE techniques. Other kinds of papers can also be easily recognized. All of these types of papers should be evaluated according to different criteria. But we are far from a consensus about what classes of paper we should distinguish, and what the criteria are for each of these classes. We see a variety of evaluation criteria in journals too. At one extreme is the set of nine genres used by IEEE Software [15], all of which have different evaluation criteria. At the other extreme is the single paper class recognized by the Requirements Engineering Journal, which has the following evaluation criteria: originality, utility, technical contribution, and relation to previous work. Apparently, the only paper class recognized by the Requirements Engineering Journal is a paper describing an original and useful solution technique. This corresponds to the “how to” genre of IEEE Software. This leaves authors and reviewers for the Requirements Engineering Journal in the dark about how other classes of papers should be judged, such as experience reports, empirical studies, or tutorials, none of which describe an original technique. This might lead to the use, by reviewers, of evaluation criteria unknown to authors, or even to the use of mutually inconsistent evaluation criteria by different reviewers of the same submission. The calls for papers of successive RE conferences, in which some of us acted as program chair, show an evolution of paper classification and evaluation schemes. Each scheme was based on the experience of the previous chair, and we tried to pass on our experience to the next chair. We also discussed our ideas with other members of the Steering Committee of the RE conferences, and with RE researchers outside the Steering Committee. This short note presents the outcome of those discussions in the form of a proposal for paper classification and a set of evaluation criteria for different paper classes. We hope to include more people in the discussion and thereby further improve the classification and evaluation scheme. In Section 2, we sketch the rationale for our classification. Section 3 presents the classification, and Section 4 concludes with a discussion of background ideas and related work."
28,2006,Static evaluation of software architectures,"The software architecture is one of the most crucial artifacts within the lifecycle of a software system. Decisions made at the architectural level directly enable, facilitate, hamper, or interfere with the achievement of business goals, functional and quality requirements. Architecture evaluations play an important role in the development and evolution of software systems since they determine how adequate the architecture is for its intended usage. This paper summarizes our practical experience with using architecture evaluations and gives an overview on when and how static architecture evaluations contribute to architecture development. We identify ten distinct purposes and needs for static architecture evaluations and illustrate them using a set of industrial and academic case studies. In particular, we show how subsequent steps in architecture development are influenced by the results from architecture evaluations"
27,2006,Suitability of requirements prioritization methods for market-driven software product development,"In a company producing off‐the‐shelf software for mass markets, the future development steps of the products cannot be negotiated with one or few customers. The decisions concerning the priorities of the requirements must be made within the company, the developer bearing all the financial risks included. This means that finding the right priorities for the requirements is important. However, requirements prioritization is recognized as a difficult activity in software product development. The literature offers methods for requirements prioritization, but many authors report that practices in companies are mostly informal. In this study, we evaluated two requirements prioritization methods in industrial product development projects. In the first case, the users of the system evaluated the pair‐wise comparison technique for prioritizing user needs. In the second case, practitioners evaluated Wiegers' method for change requests. In addition, we interviewed 11 practitioners from 6 companies about their current requirements prioritization practices and the models that they use as a basis of their prioritization decisions. Our findings indicate that prioritization methods may have limited ability to support decision‐making in a complex area like requirements prioritization in market‐driven product development. In addition, there are practical difficulties in the usage of methods, and therefore, prioritization results should be taken more as being indicative than as an ultimate truth. Copyright © 2006 John Wiley & Sons, Ltd."
26,2006,Uncovering the Reality Within Virtual Software Teams,"To support software development globalisation, organisations are increasingly implementing virtual team strategies. However, these teams have to work within the confines of the factors which distance introduces, thus not always allowing effective coordination, visibility, communication and cooperation to take place. The successful implementation and management of such teams must be done differently to those at single-site locations. To establish what factors significantly affect the implementation of virtual teams, the authors carried out qualitative research in two organisations in Ireland. Results from this research demonstrate that many factors are reality for those involved in global software development. In this paper we present five of these factors and discuss the impact these had on the virtual teams. These five are: use of communication tools, project management, process engineering, technical ability and knowledge transfer and motivational issues. If these are not explicitly addressed by management it can lead to serious problems."
29,2007,Do Gradations of Time Zone Separation Make a Difference in Performance? A First Laboratory Study,"We often hear that global software engineering teams are affected by time differences. While there is considerable research on the difficulties of distance, culture and other dimensions, there has been little research that isolated the impact of just time differences. The research question that guides us is whether there are gradual differences across time zones that impact team performance. In this study we conducted a laboratory experiment with 42 dyadic teams. The teams were randomly assigned into 4 time zone overlap conditions: full overlap, 2/3 overlap, 1/3 overlap and no overlap. Using a fictional map task, we found that participants' perceptions of process are unrelated to actual objective performance measures of speed and accuracy. Consistent with our expectations, we found that a small time separation has no effect on accuracy, but that more time separation has a significant effect on accuracy. Also consistent with our expectations, we found that a small amount of time separation has a significant effect on production speed. However, contrary to our expectations, we found that further increases in partial overlap have less significant effects on speed, and when there is no overlap speed actually increases, albeit not significantly - a ""U-shaped"" effect."
31,2007,Understanding Documentation Value in Software Maintenance,"This study examines effective documentation use in software maintenance. Interviews with software maintainers, with diverse levels of experience, revealed three themes: reliance on source code, characteristics of useful documents, and the interplay between people in the maintenance environment and documentation. All of these findings improve our understanding of the role of documentation in maintenance. This awareness has practical import - project managers can fund the most useful forms of documentation and maintainers can improve their ability to locate and reuse this information."
30,2007,Guidelines for performing systematic literature reviews in software engineering,
32,2008,Systematic mapping studies in software engineering,"BACKGROUND: A software engineering systematic map is a defined method to build a classification scheme and structure a software engineering field of interest. The analysis of results focuses on frequencies of publications for categories within the scheme. Thereby, the coverage of the research field can be determined. Different facets of the scheme can also be combined to answer more specific research questions. OBJECTIVE: We describe how to conduct a systematic mapping study in software engineering and provide guidelines. We also compare systematic maps and systematic reviews to clarify how to chose between them. This comparison leads to a set of guidelines for systematic maps. METHOD: We have defined a systematic mapping process and applied it to complete a systematic mapping study. Furthermore, we compare systematic maps with systematic reviews by systematically analyzing existing systematic reviews. RESULTS: We describe a process for software engineering systematic mapping studies and compare it to systematic reviews. Based on this, guidelines for conducting systematic maps are defined. CONCLUSIONS: Systematic maps and reviews are different in terms of goals, breadth, validity issues and implications. Thus, they should be used complementarily and require different methods (e.g., for analysis)."
33,2008,The qualitative content analysis process,"Aim. This paper is a description of inductive and deductive content analysis. Background. Content analysis is a method that may be used with either qualitative or quantitative data and in an inductive or deductive way. Qualitative content analysis is commonly used in nursing studies but little has been published on the analysis process and many research books generally only provide a short description of this method. Discussion. When using content analysis, the aim was to build a model to describe the phenomenon in a conceptual form. Both inductive and deductive analysis processes are represented as three main phases: preparation, organizing and reporting. The preparation phase is similar in both approaches. The concepts are derived from the data in inductive content analysis. Deductive content analysis is used when the structure of analysis is operationalized on the basis of previous knowledge. Conclusion. Inductive content analysis is used in cases where there are no previous studies dealing with the phenomenon or when it is fragmented. A deductive approach is useful if the general aim was to test a previous theory in a different situation or to compare categories at different time periods."
34,2008,The road ahead for mining software repositories,"Source control repositories, bug repositories, archived communications, deployment logs, and code repositories are examples of software repositories that are commonly available for most software projects. The mining software repositories (MSR) field analyzes and cross-links the rich data available in these repositories to uncover interesting and actionable information about software systems. By transforming these repositories from static record-keeping ones into active repositories, we can guide decision processes in modern software projects. For example, data in source control repositories, traditionally used to archive code, could be linked with data in bug repositories to help practitioners propagate complex changes and to warn them about risky code based on prior changes and bugs. In this paper, we present a brief history of the MSR field and discuss several recent achievements and results of using MSR techniques to support software research and practice. We then discuss the various opportunities and challenges that lie in the road ahead for this important and emerging field."
35,2009,Global Software Development: Where Are the Benefits?,"Global Software Development (GSD) is increasingly becoming the normal practice in the software industry, readily evidenced by U.S. estimates that the value of the offshore software development market has increased 25-fold over the past 10 years, to the extent that one-quarter of U.S. spending on application development, integration and management services is expected to go off-shore according to recent predictions. There are many potential benefits that can arise from GSD. The most frequently cited one is that of reduced development costs due to the salary savings possible. Also, GSD can lead to reduced development duration due to greater time zone effectiveness as companies practice the so-called 'follow-the-sun' software development model. GSD also affords new opportunities for cross-site modularization of development work, potential access to a larger and better-skilled developer pool, and the possibility of greater innovation, learning and transfer of best practices. Finally, GSD can facilitate closer proximity to markets and customers. However, GSD also introduces a number of challenges in relation to communication, coordination and control of the development process. These arise due to the distances involved in three dimensions -- geographical, temporal, and socio-cultural (See Figure 1). As a consequence, much research and practice has focused on trying to find ways to overcome the GSD challenges identified in Figure 1. In the literature to date, the potential benefits of GSD are usually just mentioned very briefly, if they are mentioned at all, and the realization of these benefits seems to be more or less taken for granted. The primary focus instead is on how the problems inherent in GSD might be addressed. Here, we reverse this trend and focus instead on the benefits and the extent to which they are actually being realized in practice in three global companies practicing GSD."
36,2010,Replicating msr: A study of the potential replicability of papers published in the mining software repositories proceedings,"This paper is the result of reviewing all papers published in the proceedings of the former International Workshop on Mining Software Repositories (MSR) (2004-2006) and now Working Conference on MSR (2007-2009). We have analyzed the papers that contained any experimental analysis of software projects for their potentiality of being replicated. In this regard, three main issues have been addressed: i) the public availability of the data used as case study, ii) the public availability of the processed dataset used by researchers and iii) the public availability of the tools and scripts. A total number of 171 papers have been analyzed from the six workshops/working conferences up to date. Results show that MSR authors use in general publicly available data sources, mainly from free software repositories, but that the amount of publicly available processed datasets is very low. Regarding tools and scripts, for a majority of papers we have not been able to find any tool, even for papers where the authors explicitly state that they have built one. Lessons learned from the experience of reviewing the whole MSR literature and some potential solutions to lower the barriers of replicability are finally presented and discussed."
37,2010,Transformation patterns for curing the human causes of technical debt,
38,2010,Theoretical maximum capacity as benchmark for empty vehicle redistribution in personal rapid transit,
41,2010,"Software architecture: foundations, theory, and practice","Software architecture has become a centerpiece subject for software engineers, both researchers and practitioners alike. At the heart of every software system is its software architecture, i.e., ""the set of principal design decisions about the system"". Architecture permeates all major facets of a software system, for principal design decisions may potentially be made at any time during a system's lifetime, and potentially by any stakeholder. Such decisions encompass structural concerns, such as the system's high-level building blocks -components, connectors, and configurations; the system's deployment; the system's non-functional properties; and the system's evolution patterns, including runtime adaptation. Software architectures found particularly useful for families of systems - product lines - are often codified into architectural patterns, architectural styles, and reusable, parameterized reference architectures. This tutorial affords the participant an extensive treatment of the field of software architecture, its foundation, principles, and elements, including those mentioned above. Additionally, the tutorial introduces the participants to the state-of-the-art as well as the state-of-the-practice in software architecture, and looks at emerging and likely future trends in this field. The discussion is illustrated with numerous real-world examples. One example given prominent treatment is the architecture of the World Wide Web and its underlying architectural style, REpresentational State Transfer (REST)."
42,2010,Multicollinearity,
39,2010,Infrastructure Debt: Revisiting the Foundation,
40,2010,Managing technical debt in software-reliant systems,"Delivering increasingly complex software-reliant systems demands better ways to manage the long-term effects of short- term expedients. The technical debt metaphor is gaining significant traction in the agile development community as a way to understand and communicate such issues. The idea is that developers sometimes accept compromises in a system in one dimension (e.g., modularity) to meet an urgent demand in some other dimension (e.g., a deadline), and that such compromises incur a “debt”: on which “interest” has to be paid and which the “principal” should be repaid at some point for the long-term health of the project. We argue that the software engineering research community has an opportunity to study and improve this concept. We can offer software engineers a foundation for managing such trade-offs based on models of their economic impacts. Therefore, we propose managing technical debt as a part of the future research agenda for the software engineering field."
43,2011,A portfolio approach to technical debt management,"Technical debt describes the effect of immature software artifacts on software maintenance - the potential of extra effort required in future as if paying interest for the incurred debt. The uncertainty of interest payment further complicates the problem of what debt should be incurred or repaid and when. To help software managers make informed decisions, a portfolio approach is proposed in this paper. The approach leverages the portfolio management theory in the finance domain to determine the optimal collection of technical debt items that should be incurred or held. We expect this approach could provide a new perspective for technical debt management."
45,2011,An Enterprise Perspective on Technical Debt,"Technical debt is a term that has been used to describe the increased cost of changing or maintaining a system due to expedient shortcuts taken during its development. Much of the research on technical debt has focused on decisions made by project architects and individual developers who choose to trade off short-term gain for a longer-term cost. However, in the context of enterprise software development, such a model may be too narrow. We explore the premise that technical debt within the enterprise should be viewed as a tool similar to financial leverage, allowing the organization to incur debt to pursue options that it couldn't otherwise afford. We test this premise by interviewing a set of experienced architects to understand how decisions to acquire technical debt are made within an enterprise, and to what extent the acquisition of technical debt provides leverage. We find that in many cases, the decision to acquire technical debt is not made by technical architects, but rather by non-technical stakeholders who cause the project to acquire new technical debt or discover existing technical debt that wasn't previously visible. We conclude with some preliminary observations and recommendations for organizations to better manage technical debt in the presence of some enterprise-scale circumstances."
46,2011,Using code analysis tools for architectural conformance checking,"Architectural conformance checking verifies whether a system conforms to its intended architecture, which is essential to safeguard the quality attributes of the system. Due to the size of many systems, performing conformance checking by means of manual code inspections is often practically infeasible. Code analysis tools can be used to automatically check architectural conformance. In this paper, we investigate several code analysis tools that offer support for Java and compare them on their usefulness for architectural conformance checking: Architecture Rules, Macker, Lattix DSM, SonarJ, Structure101 and XDepend."
47,2011,"Configuring Global Software Teams: A Multi-company Analysis of Project Productivity, Quality, and Profits","In this paper, we examined the impact of project-level configurational choices of globally distributed software teams on project productivity, quality, and profits. Our analysis used data from 362 projects of four different firms. These projects spanned a wide range of programming languages, application domain, process choices, and development sites spread over 15 countries and 5 continents. Our analysis revealed fundamental tradeoffs in choosing configurational choices that are optimized for productivity, quality, and/or profits. In particular, achieving higher levels of productivity and quality require diametrically opposed configurational choices. In addition, creating imbalances in the expertise and personnel distribution of project teams significantly helps increase profit margins. However, a profit-oriented imbalance could also significantly affect productivity and/or quality outcomes. Analyzing these complex tradeoffs, we provide actionable managerial insights that can help software firms and their clients choose configurations that achieve desired project outcomes in globally distributed software development."
44,2011,Measuring and monitoring technical debt,"Technical debt is a metaphor for immature, incomplete, or inadequate artifacts in the software development lifecycle that cause higher costs and lower quality in the long run. These artifacts remaining in a system affect subsequent development and maintenance activities, and so can be seen as a type of debt that the system developers owe the system. Incurring technical debt may speed up software development in the short run, but such benefit is achieved at the cost of extra work in the future, as if paying interest on the debt. In this sense, the technical debt metaphor characterizes the relationship between the short-term benefits of delay- ing certain software maintenance tasks or doing them quickly and less carefully, and the long-term cost of those delays. However, managing technical debt is more complicated than managing financial debt because of the uncertainty involved. In this chapter, the authors review the main issues associated with technical debt, and propose a technical debt management framework and a research plan for validation. The objective of our research agenda is to develop and validate a comprehensive technical debt theory that formalizes the relationship between the cost and benefit sides of the concept. Further, we propose to use the theory to propose mechanisms (processes and tools) for measuring and managing technical debt in software product maintenance. The theory and management mechanisms are intended ultimately to contribute to the improved quality of software and facilitate decision making in software maintenance."
50,2012,Strategic management of technical debt: Tutorial synopsis,"The technical debt metaphor acknowledges that software development teams sometimes accept compromises in a system in one dimension (for example, modularity) to meet an urgent demand in some other dimension (for example, a deadline), and that such compromises incur a ""debt"". If not properly managed the interest on this debt may continue to accrue, severely hampering system stability and quality and impacting the team's ability to deliver enhancements at a pace that satisfies business needs. Although unmanaged debt can have disastrous results, strategically managed debt can help businesses and organizations take advantage of time-sensitive opportunities, fulfill market needs and acquire stakeholder feedback. Because architecture has such leverage within the overall development life cycle, strategic management of architectural debt is of primary importance. Some aspects of technical debt - but not all technical debt - affects product quality. This tutorial introduces the technical debt metaphor, the various types of technical debt, and in particular structural or architectural debt, the techniques for measuring and communicating this technical debt, and its relationship with software quality, both internal and external quality."
51,2012,Experimentation in software engineering,
48,2012,In search of a metric for managing architectural technical debt,"Practices designed to expedite the delivery of stakeholder value can paradoxically lead to unexpected rework costs that ultimately degrade the flow of value over time. This is especially observable when features are developed based on immediate value, while dependencies that may slow down future development efforts are neglected. The technical debt metaphor conceptualizes this tradeoff between short-term and long-term value: taking shortcuts to optimize the delivery of features in the short term incurs debt, analogous to financial debt, that must be paid off later to optimize long-term success. In this paper, we describe taking an architecture-focused and measurement-based approach to develop a metric that assists in strategically managing technical debt. Such an approach can be used to optimize the cost of development over time while continuing to deliver value to the customer. We demonstrate our approach by describing its application to an ongoing system development effort."
49,2012,Global Software and IT,
52,2012,Managing technical debt,
53,2012,Strategic management of architectural technical debt,
58,2012,An empirical investigation of changes in some software properties over time,"Software metrics are easy to define, but not so easy to justify. It is hard to prove that a metric is valid, i.e., that measured numerical values imply anything on the vaguely defined, yet crucial software properties such as complexity and maintainability. This paper employs statistical analysis and tests to check some plausible assumptions on the behavior of software and metrics measured for this software in retrospective on its versions evolution history. Among those are the reliability assumption implicit in the application of any code metric, and the assumption that the magnitude of change, i.e., increase or decrease of its size, in a software artifact is correlated with changes to its version number. Putting a suite of 36 metrics to the trial, we confirm most of the assumptions on a large repository of software artifacts. Surprisingly, we show that a substantial portion of the reliability of some metrics can be observed even in random changes to architecture. Another surprising result is that Boolean-valued metrics tend to flip their values more often in minor software version increments than in major increments."
56,2012,Estimating the principal of an application's technical debt,"This article characterizes technical debt across 700 business applications, comprising 357 MLOC. These applications were analyzed against more than 1,200 rules of good architectural and coding practice. The authors present a formula with adjustable parameters for estimating the principal of technical debt from structural quality data."
59,2012,Case Study Research in Software Engineering: Guidelines and Examples,
57,2012,"Distributed Agile, Agile Testing, and Technical Debt","Agile teams create business value by responding to changing business environments and delivering working software at regular intervals. While doing so, they make design tradeoffs to satisfy business needs such as meeting a release schedule. Technical debt is the result of such decisions or tradeoffs. When this happens, agile teams must pay off the accumulated debt by improving designs during subsequent iterations in order to improve maintainability. This must happen in a systematic way so that technical debt does not swell up and damage the project. Accomplishing this is one of the major challenges in distributed agile projects. The scope of technical debt in software projects is spread across all areas including architecture, design, code, and test scripts."
55,2012,Technical debt: From metaphor to theory and practice,"The meTaphor of technical debt in software development was introduced two decades ago by Ward Cunningham1 to explain to nontechnical product stakeholders the need for what we call now “refactoring.” It has been refined and expanded since, notably by Steve McConnell in his taxonomy,2 Martin Fowler with his four quadrants,3 and Jim Highsmith and his colleagues from the Cutter Consortium with their model. of the impact of technical debt on the total cost of ownership. From the original description—“not quite right code which we postpone making it right”1—various people have used the metaphor of technical “debt” to describe many other kinds of debts or ills of software development, encom- passing broadly anything that stands in the way of deploying, selling, or evolv- ing a software system or anything that adds to the friction from which soft- ware development endeavors suffer: test debt, people debt, architectural debt, requirement debt, documenta- tion debt, or just an amorphous, all- encompassing software debt.5 Conse- quently, the concept of technical debt. in software development has become somewhat diluted lately. Is a new re- quirement, function, or feature not yet implemented “requirement debt”? Do we call postponing the development of a new function “planning debt”? The metaphor is losing some of its strength."
54,2012,A balancing act: what software practitioners have to say about technical debt,"An interview study involving 35 practitioners from a variety of domains aimed to characterize technical debt at the ground level to find out how software practitioners perceive it. The study also aimed to understand the context in which technical debt occurs, including its causes, symptoms, and effects. In addition, the study focused on how practitioners currently deal with technical debt. This analysis paints a picture of a large, complex balancing act of various short- and long-term concerns. The Web Extra gives the interview questions used by Erin Lim, Nitin Taksande, and Carolyn Seaman."
64,2013,SonarQube in action,
63,2013,What is social debt in software engineering?,"“Social debt” in software engineering informally refers to unforeseen project cost connected to a “suboptimal” development community. The causes of suboptimal development communities can be many, ranging from global distance to organisational barriers to wrong or uninformed socio-technical decisions (i.e., decisions that influence both social and technical aspects of software development). Much like technical debt, social debt impacts heavily on software development success. We argue that, to ensure quality software engineering, practitioners should be provided with mechanisms to detect and manage the social debt connected to their development communities. This paper defines and elaborates on social debt, pointing out relevant research paths. We illustrate social debt by comparison with technical debt and discuss common real-life scenarios that exhibit “sub-optimal” development communities."
65,2013,"Practical Considerations, Challenges, and Requirements of Tool-support for Managing Technical Debt","Developing a software product with a high level of quality that also meets budget and schedule is the main goal of any organization. This usually implies making tradeoffs among conflicting aspects like number of features to implement, user perceived quality, time-to-market, and the ability of the company to maintain and improve the system in a feasible way in the future (aka, managing Technical Debt (TD)). In this paper we present a fresh perspective on TD from a CMMI Maturity Level 5 company. Examples, practical considerations, and challenges in dealing with TD are presented along with ten requirements of a tool for managing TD."
66,2013,Managing Technical Debt: An Industrial Case Study,"Technical debt is the consequence of trade-offs made during software development to ensure speedy releases. The research community lacks rigorously evaluated guidelines to help practitioners characterize, manage and prioritize debt. This paper describes a study conducted with an industrial partner during their implementation of Agile development practices for a large software development division within the company. The report contains our initial findings based on ethnographic observations and semi-structured interviews. The goal is to identify the best practices regarding managing technical debt so that the researchers and the practitioners can further evaluate these practices to extend their knowledge of the technical debt metaphor. We determined that the developers considered their own taxonomy of technical debt based on the type of work they were assigned and their personal understanding of the term. Despite management's high-level categories, the developers mostly considered design debt, testing debt and defect debt. In addition to developers having their own taxonomy, assigning dedicated teams for technical debt reduction and allowing other teams about 20% of time per sprint for debt reduction are good initiatives towards lowering technical debt. While technical debt has become a well-regarded concept in the Agile community, further empirical evaluation is needed to assess how to properly apply the concept for various development organizations."
67,2013,Driving quality improvement and reducing technical debt with the definition of done,"This paper describes our experiences in using the Scrum concept of Definition of Done to drive quality improvements and reduce technical debt. We also describe how the Definition of Done can be a vehicle to implement standards, use checklists, and introduce compliance measures in the Agile development process."
62,2013,The msr cookbook: Mining a decade of research,"The Mining Software Repositories (MSR) research community has grown significantly since the first MSR workshop was held in 2004. As the community continues to broaden its scope and deepens its expertise, it is worthwhile to reflect on the best practices that our community has developed over the past decade of research. We identify these best practices by surveying past MSR conferences and workshops. To that end, we review all 117 full papers published in the MSR proceedings between 2004 and 2012. We extract 268 comments from these papers, and categorize them using a grounded theory methodology. From this evaluation, four high-level themes were identified: data acquisition and preparation, synthesis, analysis, and sharing/replication. Within each theme we identify several common recommendations, and also examine how these recommendations have evolved over the past decade. In an effort to make this survey a living artifact, we also provide a public forum that contains the extracted recommendations in the hopes that the MSR community can engage in a continuing discussion on our evolving best practices."
60,2013,An exploration of technical debt,"Context Whilst technical debt is considered to be detrimental to the long term success of software development, it appears to be poorly understood in academic literature. The absence of a clear definition and model for technical debt exacerbates the challenge of its identification and adequate management, thus preventing the realisation of technical debt's utility as a conceptual and technical communication device. Objective To make a critical examination of technical debt and consolidate understanding of the nature of technical debt and its implications for software development. Method An exploratory case study technique that involves multivocal literature review, supplemented by interviews with software practitioners and academics to establish the boundaries of the technical debt phenomenon. Result A key outcome of this research is the creation of a theoretical framework that provides a holistic view of technical debt comprising a set of technical debts dimensions, attributes, precedents and outcomes, as well as the phenomenon itself and a taxonomy that describes and encompasses different forms of the technical debt phenomenon. Conclusion The proposed framework provides a useful approach to understanding the overall phenomenon of technical debt for practical purposes. Future research should incorporate empirical studies to validate heuristics and techniques that will assist practitioners in their management of technical debt."
61,2013,Statistical methods for rates and proportions,
75,2014,An empirical investigation of modularity metrics for indicating architectural technical debt,"Architectural technical debt (ATD) is incurred by design decisions that consciously or unconsciously compromise system-wide quality attributes, particularly maintainability and evolvability. ATD needs to be identified and measured, so that it can be monitored and eventually repaid, when appropriate. In practice, ATD is difficult to identify and measure, since ATD does not yield observable behaviors to end users. One indicator of ATD, is the average number of modified components per commit (ANMCC): a higher ANMCC indicates more ATD in a software system. However, it is difficult and sometimes impossible to calculate ANMCC, because the data (i.e., the log of commits) are not always available. In this work, we propose to use software modularity metrics, which can be directly calculated based on source code, as a substitute of ANMCC to indicate ATD. We validate the correlation between ANMCC and modularity metrics through a holistic multiple case study on thirteen open source software projects. The results of this study suggest that two modularity metrics, namely Index of Package Changing Impact (IPCI) and Index of Package Goal Focus (IPGF), have significant correlation with ANMCC, and therefore can be used as alternative ATD indicators."
76,2014,"Qualitative content analysis: theoretical foundation, basic procedures and software solution",
73,2014,Architecture technical debt: Understanding causes and a qualitative model,"A known problem in large software companies is to balance the prioritization of short-term with long-term responsiveness. Specifically, architecture violations (Architecture Technical Debt) taken to deliver fast might hinder future feature development, which would hinder agility. We conducted a multiple-case embedded case study in 7 sites at 5 large companies in order to shed light on the current causes for the accumulation of Architectural Technical Debt that causes effort. We provide a taxonomy of the factors and their influence in the accumulation of debt, and we provide a qualitative model of how the debt is accumulated and recovered over time."
78,2014,Towards building a universal defect prediction model,"To predict files with defects, a suitable prediction model must be built for a software project from either itself (within-project) or other projects (cross-project). A universal defect prediction model that is built from the entire set of diverse projects would relieve the need for building models for an individual project. A universal model could also be interpreted as a basic relationship between software metrics and defects. However, the variations in the distribution of predictors pose a formidable obstacle to build a universal model. Such variations exist among projects with different context factors (e.g., size and programming language). To overcome this challenge, we propose context-aware rank transformations for predictors. We cluster projects based on the similarity of the distribution of 26 predictors, and derive the rank transformations using quantiles of predictors for a cluster. We then fit the universal model on the transformed data of 1,398 open source projects hosted on SourceForge and GoogleCode. Adding context factors to the universal model improves the predictive power. The universal model obtains prediction performance comparable to the within-project models and yields similar results when applied on five external projects (one Apache and four Eclipse projects). These results suggest that a universal defect prediction model may be an achievable goal."
77,2014,Architectural debt management in value-oriented architecting,"Architectural technical debt (ATD) may be incurred when making architecture decisions. In most cases, ATD is not effectively managed in the architecting process: It is not made explicit, and architecture decision making does not consider the ATD incurred by the different design options. This chapter proposes a conceptual model of ATD and an architectural technical debt management process applying this ATD conceptual model in order to facilitate decision making in a value-oriented perspective of architecting. We also demonstrate how ATD management can be employed in architectural synthesis and evaluation in a case study. The contribution of this work provides a controllable and predictable balance between the value and cost of architecture design in the long term."
72,2014,An exploratory study on self-admitted technical debt,"Throughout a software development life cycle, developers knowingly commit code that is either incomplete, requires rework, produces errors, or is a temporary workaround. Such incomplete or temporary workarounds are commonly referred to as 'technical debt'. Our experience indicates that self-admitted technical debt is common in software projects and may negatively impact software maintenance, however, to date very little is known about them. Therefore, in this paper, we use source-code comments in four large open source software projects-Eclipse, Chromium OS, Apache HTTP Server, and ArgoUML to identify self-admitted technical debt. Using the identified technical debt, we study 1) the amount of self-admitted technical debt found in these projects, 2) why this self-admitted technical debt was introduced into the software projects and 3) how likely is the self-admitted technical debt to be removed after their introduction. We find that the amount of self-admitted technical debt exists in 2.4%-31% of the files. Furthermore, we find that developers with higher experience tend to introduce most of the self-admitted technical debt and that time pressures and complexity of the code do not correlate with the amount of self-admitted technical debt. Lastly, although self-admitted technical debt is meant to be addressed or removed in the future, only between 26.3%-63.5% of self-admitted technical debt gets removed from projects after introduction."
70,2014,Incremental origin analysis of source code files,"The history of software systems tracked by version control systems is often incomplete because many file movements are not recorded. However, static code analyses that mine the file history, such as change frequency or code churn, produce precise results only if the complete history of a source code file is available. In this paper, we show that up to 38.9% of the files in open source systems have an incomplete history, and we propose an incremental, commit-based approach to reconstruct the history based on clone information and name similarity. With this approach, the history of a file can be reconstructed across repository boundaries and thus provides accurate information for any source code analysis. We evaluate the approach in terms of correctness, completeness, performance, and relevance with a case study among seven open source systems and a developer survey."
71,2014,Technical debt and the effect of agile software development practices on it-an industry practitioner survey,"A major reason for the popularity of agile and lean software methods is their capability to function in resource scarce and requirement erratic environments. Both of these characteristics cause accumulation of technical debt, something that is the end result of either intentional or unintentional decisions. The ability of these methods to function with technical debt indicates that they contain components with inherent technical debt management capabilities. This study conducts a survey on industry practitioners to discover what is their level of technical debt knowledge, how does technical debt manifest in their projects and which of the applied components of agile software development -- both processes and practices -- are sensitive to technical debt. This paper contributes to the technical debt discussion by showing differences in assumed and indicated technical debt knowledge. Furthermore, components closest to implementation and its maintenance are perceived to have the most positive effects on technical debt management. Finally, the most encountered instances of technical debt are caused by architectural inadequacies, they are internal legacy, and increase in size as a result of continued implementation."
69,2014,Titan: A toolset that connects software architecture with quality analysis,"In this tool demo, we will illustrate our tool---Titan---that supports a new architecture model: design rule spaces (DRSpaces). We will show how Titan can capture both architecture and evolutionary structure and help to bridge the gap between architecture and defect prediction. We will demo how to use our toolset to capture hundreds of buggy files into just a few architecturally related groups, and to reveal architecture issues that contribute to the error-proneness and change-proneness of these groups. Our tool has been used to analyze dozens of large-scale industrial projects, and has demonstrated its ability to provide valuable direction on which parts of the architecture are problematic, and on why, when, and how to refactor. The video demo of Titan can be found at https://art.cs.drexel.edu/~lx52/titan.mp4"
68,2014,Blending and reusing rules for architectural degradation prevention,"As software systems are maintained, their architecture often de-grades through the processes of architectural drift and erosion. These processes are often intertwined and the same modules in the code become the locus of both drift and erosion symptoms. Thus, architects should elaborate architecture rules for detecting occur-rences of both degradation symptoms. While the specification of such rules is time-consuming, they are similar across software projects adhering to similar architecture decompositions. Unfortu-nately, existing anti-degradation techniques are limited as they focus only on detecting either drift or erosion symptoms. They also do not support the reuse of recurring anti-degradation rules. In this context, the contribution of this paper is twofold. First, it presents TamDera, a domain-specific language for: (i) specifying rule-based strategies to detect both erosion and drift symptoms, and (ii) promoting the hierarchical and compositional reuse of design rules across multiple projects. The language was designed with usual concepts from programming languages in mind such as, inheritance and modularization. Second, we evaluated to what extent developers would benefit from the definition and reuse of hybrid rules. Our study involved 21 versions pertaining to 5 software projects, and more than 600 rules. On average 45% of classes that had drift symptoms in first versions presented inter-related erosion problems in latter versions or vice-versa. Also, up to 72% of all the TamDera rules in a project are from a pre-defined library of reusable rules. They were responsible for detecting on average of 73% of the inter-related degradation symptoms across the projects."
1,2014,Architectural Technical Debt: Models and Impact,"problem and motivation A known problem in large software companies is to balance the prioritization of short-term with long-term responsiveness. To illustrate such a phenomenon, a financial metaphor has been coined, which relates taking sub-optimal decisions in order to meet short-term goals to taking a financial debt, which has to be repaid with interests in the long term. Such a concept is referred to as Technical Debt (TD), and recently it has been recognized as a useful basis for the development of theoretical and practical frameworks (Kruchten et al., 2012). Tom et al. (Tom et al., 2013) have explored the TD metaphor and outlined a first framework in 2013. Part of the overall TD is to be related to architecture sub-optimal decisions, and it’s regarded as Architecture Technical Debt (ADT). ATD is regarded as violations in the code towards an intended architecture. The problem of visualizing and communicating the ATD is particularly relevant for large companies, where the architecture documentation is not capable of capturing all the updated information for compliance checking of the source code. It’s therefore difficult, both for software architects and managers not involved directly in the development of parts of the system, to monitor and understand the level of current ATD. This, in turn, affects negatively their ability of taking informed decision about the prioritization of architectural improvements and refactorings and about estimating the time needed for product development. ATD has been recognized as part of TD, but the specific phenomenon of accumulation of ATD, its recovery to avoid the later payment of interest (in terms of effort) and the impact (effects) of such interest in future development has not been tackled yet."
74,2014,Evaluating Technical Debt in Cloud-Based Architectures Using Real Options,"A Cloud-based Service-Oriented Architecture (CBSOA) is typically composed of web services, which are offered off the cloud marketplace. CB-SOA can improve its utility and add value to its composition by switching among its constituent services. We look at the option to defer the decision of substitution under uncertainty. We exploit Binomial Options to the formulation. We quantify the time-value of the architecture decisions of switching web services and technical debt they can imply on the structure. As CB-SOA are market-sensitive, dynamic and volatile, the decision of deferral tends to be sensitive to these dynamics. Henceforth, the structural complexity of a CB-SOAcan change over time and so the technical debt as its constituent web services are modified, replaced, upgraded, etc. The method builds on Design Structure Matrix (DSM) and introduces time and complexity aware propagation cost metrics to assess the value of deferral decisions relative to changes in the structure. Architects of CB-SOA can use our method to assess the time value of deferring the decisions to switch web services relative to complexity, technical debt and value creation. We demonstrate the applicability of the method using an illustrative example."
86,2015,A Unified Approach to Architecture Conformance Checking,"Software erosion can be controlled by periodically checking for consistency between the de facto architecture and its theoretical counterpart. Studies show that this process is often not automated and that developers still rely heavily on manual reviews, despite the availability of a large number of tools. This is partially due to the high cost involved in setting up and maintaining tool-specific and incompatible test specifications that replicate otherwise documented invariants. To reduce this cost, our approach consists in unifying the functionality provided by existing tools under the umbrella of a common business-readable DSL. By using a declarative language, we are able to write tool-agnostic rules that are simple enough to be understood by untrained stakeholders and, at the same time, can be interpreted as a rigorous specification for checking architecture conformance."
79,2015,Applicability of technical debt as a concept to understand obstacles for evolution of automated production systems,"Automated production systems (aPS), a specific class of mechatronic systems, are complex, long living, software intensive, evolving systems designed according to customer request. Often, the evolution of such systems has to cope with imponderables and sudden disturbances of the systematic development or maintenance process. In software engineering, the concept of technical debt and, in more detail, architectural technical debt has been introduced recently to describe phenomena, which increase software development costs over time. This paper tries to adapt and apply the classification of technical debt and architectural technical debt to automated production systems, identifying similar dimensions but adding specific challenges, causes and their effects. Once the causes and effects are identified, management and recovery strategies coping with technical debt and architectural technical debt shall be developed in the future, thereby enlarging the strategies from software engineering. The adapted classification and adaptations are based on the experience of several industrial projects in aPS."
81,2015,Towards prioritizing architecture technical debt: information needs of architects and product owners,"Architectural Technical Debt is a metaphor for representing sub-optimal architectural solutions that might cause an interest, in terms of effort or quality, to be paid by the organization in the long run. Such metaphor has been regarded as useful for communicating risks of suboptimal solutions between technical and non-technical stakeholders. However, it's fundamental to understand the information needs of the involved stakeholders in order to produce technical debt measurements that would allow proper communication and informed prioritization. We have investigated, through a combination of interviews, observations and a survey, what key information is needed by agile product owners and software architects in order to prioritize the refactoring of risky architectural technical debt items with respect to feature development."
82,2015,Addressing efficiency interest in architectural technical debt-A measurement and visualization approach for embedded software,"Addressing and managing technical debt is an important part of software development. Unmanaged technical debt, especially architectural technical debt, can lead to additional development overhead and expensive refactoring. However, most research that address architectural technical debt does so by analyzing source code; very little research focus on a more abstract level. The problem with analyzing source code to identify debt is that it is not enough to cover all debt. Similarly, most visualisation of software architecture target lower level artifacts based on static code analysis. Therefore there is a gap in both addressing architectural technical debt and software visualisation on a more abstract level. By utilizing a case study at a company, followed by design research, we contribute to filling this gap by identifying, measuring, and visualizing architectural debt on a higher abstraction level. Specifically, we identify occurring debt items related to efficiency interest and propose methodologies to measure and visualize them utilizing architectural models. Thus, we provide novel techniques of"
84,2015,The financial aspect of managing technical debt: A systematic literature review,"Context Technical debt is a software engineering metaphor, referring to the eventual financial consequences of trade-offs between shrinking product time to market and poorly specifying, or implementing a software product, throughout all development phases. Based on its inter-disciplinary nature, i.e. software engineering and economics, research on managing technical debt should be balanced between software engineering and economic theories. Objective The aim of this study is to analyze research efforts on technical debt, by focusing on their financial aspect. Specifically, the analysis is carried out with respect to: (a) how financial aspects are defined in the context of technical debt and (b) how they relate to the underlying software engineering concepts. Method In order to achieve the abovementioned goals, we employed a standard method for SLRs and applied it on studies retrieved from seven general-scope digital libraries. In total we selected 69 studies relevant to the financial aspect of technical debt. Results The most common financial terms that are used in technical debt research are principal and interest, whereas the financial approaches that have been more frequently applied for managing technical debt are real options, portfolio management, cost/benefit analysis and value-based analysis. However, the application of such approaches lacks consistency, i.e., the same approach is differently applied in different studies, and in some cases lacks a clear mapping between financial and software engineering concepts. Conclusion The results are expected to prove beneficial for the communication between technical managers and project managers, in the sense that they will provide a common vocabulary, and will help in setting up quality-related goals, during software development. To achieve this we introduce: (a) a glossary of terms and (b) a classification scheme for financial approaches used for managing technical debt. Based on these, we have been able to underline interesting implications for researchers and practitioners."
80,2015,Architectural technical debt identification based on architecture decisions and change scenarios,"Architectural technical debt (ATD) is incurred by design decisions that intentionally or unintentionally compromise system-wide quality attributes, particularly maintainability and evolvability. ATD is harmful to the system's long-term health, thus it needs to be identified for further management. However, existing ATD identification approaches are mainly based on source code analysis and thus suffer from certain shortcomings: they can only identify issues at the system implementation, they can only be employed after the systems is implemented in code, they lack a mechanism to confirm whether the potential ATD identified is real ATD or not. To address these issues, we proposed an ATD identification approach based on architecture decisions and change scenarios. To evaluate the effectiveness and usability of this approach, we conducted a case study with an information system in a large telecommunications company. The results show that the proposed approach is useful and easy to use, and it supports release planning and ATD interest measurement."
87,2015,A Case Study in Locating the Architectural Roots of Technical Debt,"Our recent research has shown that, in large-scale software systems, defective files seldom exist alone. They are usually architecturally connected, and their architectural structures exhibit significant design flaws which propagate bugginess among files. We call these flawed structures the architecture roots, a type of technical debt that incurs high maintenance penalties. Removing the architecture roots of bugginess requires refactoring, but the benefits of refactoring have historically been difficult for architects to quantify or justify. In this paper, we present a case study of identifying and quantifying such architecture debts in a large-scale industrial software project. Our approach is to model and analyze software architecture as a set of design rule spaces (DRSpaces). Using data extracted from the project's development artifacts, we were able to identify the files implicated in architecture flaws and suggest refactorings based on removing these flaws. Then we built economic models of the before and (predicted) after states, which gave the organization confidence that doing the refactorings made business sense, in terms of a handsome return on investment."
92,2015,A systematic mapping study on technical debt and its management,"Context Technical debt (TD) is a metaphor reflecting technical compromises that can yield short-term benefit but may hurt the long-term health of a software system. Objective This work aims at collecting studies on TD and TD management (TDM), and making a classification and thematic analysis on these studies, to obtain a comprehensive understanding on the TD concept and an overview on the current state of research on TDM. Method A systematic mapping study was performed to identify and analyze research on TD and its management, covering publications between 1992 and 2013. Results Ninety-four studies were finally selected. TD was classified into 10 types, 8 TDM activities were identified, and 29 tools for TDM were collected. Conclusions The term “debt” has been used in different ways by different people, which leads to ambiguous interpretation of the term. Code-related TD and its management have gained the most attention. There is a need for more empirical studies with high-quality evidence on the whole TDM process and on the application of specific TDM approaches in industrial settings. Moreover, dedicated TDM tools are needed for managing various types of TD in the whole TDM process."
85,2015,An analysis of techniques and methods for technical debt management: a reflection from the architecture perspective,"Technical debt is a metaphor referring to the consequences of weak software development. Managing technical debt is necessary in order to keep it under control, and several techniques have been developed with the goal of accomplishing this. However, available techniques have grown disperse and managers lack guidance. This paper covers this gap by providing a systematic mapping of available techniques and methods for technical debt management, covering architectural debt, and identifying existing gaps that prevent to manage technical debt efficiently."
94,2015,Extending survivability models for global software development with media synchronicity theory,"In this paper we propose a new framework to assess survivability of software projects accounting for media capability details as introduced in Media Synchronicity Theory (MST). Specifically, we add to our global engineering framework the assessment of the impact of inadequate conveyance and convergence available in the communication infrastructure selected to be used by the project, on the system ability to recover from project disasters. We propose an analytical model to assess how the project recovers from project disasters related to process and communication failures. Our model is based on media synchronicity theory to account for how information exchange impacts recovery. Then, using the proposed model we evaluate how different interventions impact communication effectiveness. Finally, we parameterize and instantiate the proposed survivability model based on a data gathering campaign comprising thirty surveys collected from senior global software development experts at ICGSE’2014 and GSD’2015."
93,2015,The danger of architectural technical debt: Contagious debt and vicious circles,"A known problem in large software companies is to balance the prioritization of short-term with long-term viability. Specifically, architecture violations (Architecture Technical Debt) taken to deliver fast might hinder future feature development. However, some technical debt requires more interest to be paid than other. We have investigated which Technical Debt items generate more effort and how this effort is manifested during software development. We conducted a multiple-case embedded case study comprehending 7 sites at 5 large international software companies. We found that some Technical Debt items are contagious, causing other parts of the system to be contaminated with the same problem, which may lead to non-linear growth of interest. We also identify another socio-technical phenomenon, for which a combination of weak awareness of debt, time pressure and refactoring creates Vicious Circles of events during the development. Such phenomena need to be identified and stopped before the development is led to a crisis point. Finally, this paper presents a taxonomy of the most dangerous items identified during the qualitative investigation and a model of their effects that can be used for prioritization, for further investigation and as a quality model for extracting more precise and context-specific metrics."
88,2015,Research Methods: The Essential Knowledge Base,
83,2015,Investigating Architectural Technical Debt accumulation and refactoring over time: A multiple-case study,"Context A known problem in large software companies is to balance the prioritization of short-term with long-term feature delivery speed. Specifically, Architecture Technical Debt is regarded as sub-optimal architectural solutions taken to deliver fast that might hinder future feature development, which, in turn, would hinder agility. Objective This paper aims at improving software management by shedding light on the current factors responsible for the accumulation of Architectural Technical Debt and to understand how it evolves over time. Method We conducted an exploratory multiple-case embedded case study in 7 sites at 5 large companies. We evaluated the results with additional cross-company interviews and an in-depth, company-specific case study in which we initially evaluate factors and models. Results We compiled a taxonomy of the factors and their influence in the accumulation of Architectural Technical Debt, and we provide two qualitative models of how the debt is accumulated and refactored over time in the studied companies. We also list a set of exploratory propositions on possible refactoring strategies that can be useful as insights for practitioners and as hypotheses for further research. Conclusion Several factors cause constant and unavoidable accumulation of Architecture Technical Debt, which leads to development crises. Refactorings are often overlooked in prioritization and they are often triggered by development crises, in a reactive fashion. Some of the factors are manageable, while others are external to the companies. ATD needs to be made visible, in order to postpone the crises according to the strategic goals of the companies. There is a need for practices and automated tools to proactively manage ATD."
91,2015,A Recommendation System for Repairing Violations Detected by Static Architecture Conformance Checking,"This paper describes a recommendation system that provides refactoring guidelines for maintainers when tackling architectural erosion. The paper formalizes 32 refactoring recommendations to repair violations raised by static architecture conformance checking approaches; it describes a tool—called ArchFix—that triggers the proposed recommendations; and it evaluates the application of this tool in two industrial‐strength systems. For the first system—a 21 KLOC open‐source strategic management system—our approach has indicated correct refactoring recommendations for 31 out of 41 violations detected as the result of an architecture conformance process. For the second system—a 728 KLOC customer care system used by a major telecommunication company—our approach has triggered correct recommendations for 624 out of 787 violations, as asserted by the system's architect. Moreover, the architects have scored 82% of these recommendations as having moderate or major complexity."
90,2015,Global software engineering: An industry perspective,"Abstract: Professional software products and IT systems and services today are developed mostly by globally distributed teams, projects, and companies. This issue's column summarizes experiences and guidance from industry to facilitate knowledge and technology transfer. It's based on industry feedback from the annual IEEE International Conference on Global Software Engineering."
89,2015,Applied regression analysis and generalized linear models,
95,2015,Identifying and visualizing Architectural Debt and its efficiency interest in the automotive domain: A case study,"Architectural Technical Debt has recently received the attention of the scientific community, as a suitable metaphor for describing sub-optimal architectural solutions having short- term benefits but causing a long-term negative impact. We study such phenomenon in the context of Volvo Car Group, where the development of modern cars includes complex systems with mechanical components, electronics and software working together in a complicated network to perform an increasing number of functions and meet the demands of many customers. This puts high requirements on having an architecture and design that can handle these demands. Therefore, it is of utmost importance to manage Architecture Technical Debt, in order to make sure that the advantages of sub-optimal solutions do not lead to the payment of a large interest. We conducted a case study at Volvo Car Group and we discovered that architectural violations in the detailed design had an impact on the efficiency of the communication between components, which is an essential quality in cars and other embedded systems. Such interest is not studied in literature, which usually focuses on the maintainability aspects of Technical Debt. To explore how this Architectural Technical Debt and its interest could be communicated to stakeholders, we developed a visual tool. We found that not only was the Architectural Debt highly interesting for the architects and other stakeholders at VCG, but the proposed visualization was useful in increasing the awareness of the impact that Architectural Technical Debt had on efficiency."
103,2016,Architecture viewpoints for documenting architectural technical debt,"Technical debt (TD) has attracted an increasing interest from researchers and practitioners in the software engineering domain. Currently, most approaches to managing TD focus on dealing with TD at source code level, while few methods deal with TD at architecture level. If architectural technical debt (ATD) is not effectively managed in the architecting process, the knowledge about ATD is not made available to involved stakeholders and the impact of ATD is not considered during architecture decision-making. Thus, the system’s maintainability and evolvability can be intentionally or unintentionally compromised. As a result, architectures are costly to maintain and new features are difficult to introduce. To facilitate the management of ATD, it needs to be documented so that it becomes explicit to stakeholders. To this end, we propose a set of architecture viewpoints related to ATD (ATD viewpoints in short). Each viewpoint frames a number of concerns related to ATD. These ATD viewpoints together help to get a comprehensive understanding of ATD in a software system, thereby providing support for architecture decision-making. To evaluate the effectiveness of the ATD viewpoints in documenting ATD, we conducted a case study in a large telecommunications company. The results of this case study show that the documented ATD views can effectively facilitate the documentation of ATD. Specifically, the ATD viewpoints are relatively easy to understand; it takes an acceptable amount of effort to document ATD using the ATD viewpoints; and the documented ATD views are useful for stakeholders to understand the ATD in the software project."
102,2016,How do software development teams manage technical debt? An empirical study,"Technical debt (TD) is a metaphor for taking shortcuts or workarounds in technical decisions to gain short-term benefit in time-to-market and earlier software release. In this study, one large software development organization is investigated to gather empirical evidence related to the concept of technical debt management (TDM). We used the exploratory case study method to collect and analyze empirical data in the case organization by interviewing a total of 25 persons in eight software development teams. We were able to identify teams where the current strategy for TDM was only to fix TD when necessary, when it started to cause too much trouble for development. We also identified teams where the management had a systematic strategy to identify, measure and monitor TD during the development process. It seems that TDM can be associated with a similar maturity concept as software development in general. Development teams may raise their maturity by increasing their awareness and applying more advanced processes, techniques and tools in TDM. TDM is an essential part of sustainable software development, and companies have to find right approaches to deal with TD to produce healthy software that can be developed and maintained in the future. © 2016 The Authors"
101,2016,Identification and management of technical debt: A systematic mapping study,"Context: The technical debt metaphor describes the effect of immature artifacts on software maintenance that bring a short-term benefit to the project in terms of increased productivity and lower cost, but that may have to be paid off with interest later. Much research has been performed to propose mechanisms to identify debt and decide the most appropriate moment to pay it off. It is important to investigate the current state of the art in order to provide both researchers and practitioners with information that enables further research activities as well as technical debt management in practice. Objective: This paper has the following goals: to characterize the types of technical debt, identify indica- tors that can be used to find technical debt, identify management strategies, understand the maturity level of each proposal, and identify what visualization techniques have been proposed to support technical debt identification and management activities. Method: A systematic mapping study was performed based on a set of three research questions. In total, 100 studies, dated from 2010 to 2014, were evaluated. Results: We proposed an initial taxonomy of technical debt types, created a list of indicators that have been proposed to identify technical debt, identified the existing management strategies, and analyzed the current state of art on technical debt, identifying topics where new research efforts can be invested. Conclusion: The results of this mapping study can help to identify points that still require further investigation in technical debt research."
100,2016,The Perception of Technical Debt in the Embedded Systems Domain: An Industrial Case Study,"Technical Debt Management (TDM) has drawn the attention of software industries during the last years, including embedded systems. However, we currently lack an overview of how practitioners from this application domain perceive technical debt. To this end, we conducted a multiple case study in the embedded systems industry, to investigate: (a) the expected life-time of components that have TD, (b) the most frequently occurring types of TD in them, and (c) the significance of TD against run-time quality attributes. The case study was performed on seven embedded systems industries (telecommunications, printing, smart manufacturing, sensors, etc.) from five countries (Greece, Netherlands, Sweden, Austria, and Finland). The results of the case study suggest that: (a) maintainability is more seriously considered when the expected lifetime of components is larger than ten years, (b) the most frequent types of debt are test, architectural, and code debt, and (c) in embedded systems the run-time qualities are prioritized compared to design-time qualities that are usually associated with TD. The obtained results can be useful for both researchers and practitioners: the former can focus their research on the most industrially-relevant aspects of TD, whereas the latter can be informed about the most common types of TD and how to focus their TDM processes. © 2016 IEEE."
96,2016,Global software engineering: Evolution and trends,"Professional software products and IT systems and services today are developed mostly by globally distributed teams, projects, and companies. Successfully orchestrating Global Software Engineering (GSE) has become the major success factor both for organizations and practitioners. Yet, more than a half of all distributed projects does not achieve the intended objectives and is canceled. This paper summarizes experiences from academia and industry in a way to facilitate knowledge and technology transfer. It is based on an evaluation of 10 years of research, and industry collaboration and experience reported at the IEEE International Conference on Software Engineering (ICGSE) series. The outcomes of our analysis show GSE as a field highly attached to industry and, thus, a considerable share of ICGSE papers address the transfer of Software Engineering concepts and solutions to the global stage. We found collaboration and teams, processes and organization, sourcing and supplier management, and success factors to be the topics gaining the most interest of researchers and practitioners. Beyond the analysis of the past conferences, we also look at current trends in GSE to motivate further research and industrial collaboration."
98,2016,Exploring the costs of technical debt management – a case study,"Technical debt is a metaphor for delayed software maintenance tasks. Incurring technical debt may bring short-term benefits to a project, but such benefits are often achieved at the cost of extra work in future, analogous to paying interest on the debt. Currently technical debt is managed implicitly, if at all. However, on large systems, it is too easy to lose track of delayed tasks or to misunderstand their impact. Therefore, we have proposed a new approach to managing technical debt, which we believe to be helpful for software managers to make informed decisions. In this study we explored the costs of the new approach by tracking the technical debt management activities in an on-going software project. The results from the study provided insights into the impact of technical debt management on software projects. In particular, we found that there is a significant start-up cost when beginning to track and monitor technical debt, but the cost of ongoing management soon declines to very reasonable levels. © 2014, Springer Science+Business Media New York."
97,2016,Developing Processes to Increase Technical Debt Visibility and Manageability: An Action Research Study in Industry,"The knowledge about technical debt and its management has increased in recent years. The interest of academia and industry has generated many viewpoints on technical debt. Technical debt management consists of technical and organizational aspects, which make it a challenge in software development. To increase technical debt visibility and manageability, new processes must be developed and thoroughly empirically tested for their applicability. In this paper, we use the action research methodology to design processes for identification, documentation, and prioritization of technical debt. Our partner in this research is a large Nordic IT company Tieto, currently in a need for new ways to improve their technical debt management. The results include a set of processes and templates that were successfully used to identify and document technical debt. The identified technical debt items were later prioritized based on evaluation by Tieto employees. Tieto was able to create a prioritized technical debt backlog, which is now used for reduction activities to create a healthy and sustainable product for the future."
104,2016,A Decision Framework on Refactoring Architectural Technical Debt: Paying Back in Modularity-An Industrial Case Study,"Technical debt refers to sub-optimal solutions during software development where there is a trade-o between short-term and long-term goals. Lately there has been a few studies which identi es technical debt, however most of the do not estimate the interest which is associated with the identi ed debt. Knowing how much interest is being paid allows the developers to make informed decisions of what will bene t the development. One example is knowing if a onetime cost of a repaying the debt outweighs the cost of paying the interest of that debt. This would mean that the repayment can be seen as an investment for future development. This thesis aims to develop a decision framework that can be used when deciding if part of a component would bene t from being modularized into a new component or framework to repay a debt. To accomplish this, the study developed two methods that are used by the decision framework. The rst method is to nd out if the analysed part of the components would bene t from such a modularization. The second method estimates how much e ort can be saved by doing a modularization. It was found that for the rst method, a measurement system which analysed the component's source code was a good approach in deciding if a modularization would be bene cial. For the second method an approach which used data regarding the current e ort distribution to estimate the e ort saved by modularizing was chosen. The result of combining the two methods was found to be an adequate decision framework which provides useful information in the decision if to modularize part of a component or not."
108,2016,An empirically developed method to aid decisions on architectural technical debt refactoring: AnaConDebt,"Architectural Technical Debt is regarded as sub-optimal architectural solutions that need to be refactored in order to avoid the payment of a costly interest in the future. However, decisions on if and when to refactor architecture are extremely important and difficult to take, since changing software at the architectural level is quite expensive. Therefore it is important, for software organizations, to have methods and tools that aid architects and managers to understand if Architecture Technical Debt will generate a costly and growing interest to be paid or not. Current knowledge, especially empirically developed and evaluated, is quite scarce. In this paper we developed and evaluated a method, AnaConDebt, by analyzing, together with several practitioners, 12 existing cases of Architecture Debt in 6 companies. The method has been refined several times in order to be useful and effective in practice. We also report the evaluation of the method with a final case, for which we present anonymized results and subsequent refactoring decisions. The method consists of several components that need to be analyzed, combining the theoretical Technical Debt framework and the practical experience of the practitioners, in order to identify the key factors involved in the growth of interest. The output of the method shows summarized indicators that visualizes the factors in a useful way for the stakeholders. This analysis aids the practitioners in deciding on if and when to refactor Architectural Technical Debt items. The method has been evaluated and has been proven useful to support the architects into systematically analyze and decide upon a case."
99,2016,Identification of architectural technical debt: An analysis based on naming patterns,"Hasty software development can produce immediate implementations with source code unnecessarily complex and hardly readable. These small kinds of software decay generate a technical debt that could be big enough to seriously affect future maintenance activities. This work presents an analysis technique for identifying architectural technical debt related to non-uniformity of naming patterns; the technique is based on term frequency over package hierarchies. The proposal has been evaluated on projects of two popular organizations, Apache and Eclipse. The results have shown that most of the projects have frequent occurrences of the proposed naming patterns, and using a graph model and aggregated data could enable the elaboration of simple queries for debt identification. The technique has features that favor its applicability on emergent architectures and agile software development."
113,2016,Identifying and quantifying architectural debt,"Our prior work showed that the majority of error-prone source files in a software system are architecturally connected. Flawed architectural relations propagate defectsamong these files and accumulate high maintenance costs over time, just like debts accumulate interest. We model groups of architecturally connected files that accumulate high maintenance costs as architectural debts. To quantify such debts, we formally define architectural debt, and show how to automatically identify debts, quantify their maintenance costs, and model these costs over time. We describe a novel history coupling probability matrix for this purpose, and identify architecture debts using 4 patterns of architectural flaws shown to correlate with reduced software quality. We evaluate our approach on 7 large-scale open source projects, and show that a significant portion of total project maintenance effort is consumed by paying interest on architectural debts. The top 5 architectural debts, covering a small portion (8% to 25%) of each project's error-prone files, capture a significant portion (20% to 61%) of each project's maintenance effort. Finally, we show that our approach reveals how architectural issues evolve into debts over time."
117,2016,Context-based code quality assessment,"Two tasks that software engineers constantly perform are writing code that is easy to evolve and maintain, and detecting poorly written pieces of code. For the former, software engineers commonly rely on well-known software architecture styles, such as Model-View-Controller (MVC). To the latter, they rely on code metrics and code smell detection approaches. However, up to now, these code metrics and code smell approaches do not take into account underlying architectureall classes are assessed as if they were the same. In practice, software developers know that classes differ in terms of responsibilities and implementation, and thus, we expect these classes to present different levels of coupling, cohesion, and complexity. As an example, in an MVC system, Controllers are responsible for the flow between the Model and the View, and Models are responsible for representing the systems business concepts. Thus, in this thesis, we evaluate the impact of architectural roles within a system architecture on code metrics and code smells. We performed an empirical analysis in 120 open source systems, and interviewed and surveyed more than 50 software developers. Our findings show that each architectural role has a different code metric values distribution, which is a likely consequence of their specific responsibilities. Thus, we propose SATT, an approach that provides specific thresholds for architectural roles that are significantly different from others in terms of code smells. We also show that classes that play a specific architectural role contain specific code smells, which developers perceive as problems, and can impact class' change- and defect-proneness. Based on our findings, we suggest that developers understand the responsibilities of each architectural role in their system architecture, so that code metrics and code smells techniques can provide more accurate feedback."
106,2016,Technical debt and system architecture: The impact of coupling on defect-related activity,"Technical Debt is created when design decisions that are expedient in the short term increase the costs of maintaining and adapting this system in future. An important component of technical debt relates to decisions about system architecture. As systems grow and evolve, their architectures can degrade, increasing maintenance costs and reducing developer productivity. This raises the question if and when it might be appropriate to redesign (“refactor”) a system, to reduce what has been called “architectural debt”. Unfortunately, we lack robust data by which to evaluate the relationship between architectural design choices and system maintenance costs, and hence to predict the value that might be released through such refactoring efforts. We address this gap by analyzing the relationship between system architecture and maintenance costs for two software systems of similar size, but with very different structures; one has a “Hierarchical” design, the other has a “Core-Periphery” design. We measure the level of system coupling for the 20,000+ components in each system, and use these measures to predict maintenance efforts, or “defect-related activity.” We show that in both systems, the tightly-coupled Core or Central components cost significantly more to maintain then loosely-coupled Peripheral components. In essence, a small number of components generate a large proportion of system costs. However, we find major differences in the potential benefits available from refactoring these systems, related to their differing designs. Our results generate insight into how architectural debt can be assessed by understanding patterns of coupling among components in a system."
116,2016,Software architecture health monitor,"In this paper, we first discuss the concept of architecture debt and how this debt grows in virtually every software-intensive project. Next we propose a methodology for developers to monitor the health of a project's architecture through an analysis of the development artifacts that a project produces. Our objective is to monitor and manage architecture debt by leveraging an architecture model that we proposed recently, called the Design Rule Space (DRSpace). We use DRSpaces to split a complex system into smaller subsystems based on features, patterns, refactoring targets, etc., so that we can monitor and analyze the evolution and interaction of each subsystem separately. We also employ a recently proposed architectural metric---Decoupling Level---to quantitatively monitor changes in a project's overall level of architecture maintainability. Using these tools, we describe our vision for a software architecture ""health monitor"", on analogy with a health monitor used in a hospital, to continuously monitor the health of the ""patient"" and alert staff to any potential danger signs."
114,2016,Mining architectural violations from version history,"Software architecture conformance is a key software quality control activity that aims to reveal the progressive gap normally observed between concrete and planned software architectures. However, formally specifying an architecture can be difficult, as it must be done by an expert of the system having a high level understanding of it. In this paper, we present a lightweighted approach for architecture conformance based on a combination of static and historical source code analysis. The proposed approach relies on four heuristics for detecting absences (something expected was not found) and divergences (something prohibited was found) in source code based architectures. We also present an architecture conformance process based on the proposed approach. We followed this process to evaluate the architecture of two industrial-strength information systems, achieving an overall precision of 62.7 % and 53.8 %. We also evaluated our approach in an open-source information retrieval library, achieving an overall precision of 59.2 %. We envision that an heuristic-based approach for architecture conformance can be used to rapidly raise architectural warnings, without deeply involving experts in the process."
115,2016,Experiences from measuring learning and performance in large-scale distributed software development,"Background: Developers and development teams in large-scale software development are often required to learn continuously. Organizations also face the need to train and support new developers and teams on-boarded in ongoing projects. Although learning is associated with performance improvements, experience shows that training and learning does not always result in a better performance or significant improvements might take too long. Aims: In this paper, we report our experiences from establishing an approach to measure learning results and associated performance impact for developers and teams in Ericsson. Method: Experiences reported herein are a part of an exploratory case study of an on-going large-scale distributed project in Ericsson. The data collected for our measurements included archival data and expert knowledge acquired through both unstructured and semi-structured interviews. While performing the measurements, we faced a number of challenges, documented in the form of lessons learned. Results: We aggregated our experience in eight lessons learned related to collection, preparation and analysis of data for further measurement of learning potential and performance in large-scale distributed software development. Conclusions: Measuring learning and performance is a challenging task. Major problems were related to data inconsistencies caused by, among other factors, distributed nature of the project. We believe that the documented experiences shared herein can help other researchers and practitioners to perform similar measurements and overcome the challenges of large-scale distributed software projects, as well as proactively address these challenges when establishing project measurement programs."
112,2016,The introduction of technical debt tracking in large companies,"Large software companies need to support continuous and fast delivery of customer value both in the short and long term. However, this can be hindered if both evolution and maintenance of existing systems are hampered by Technical Debt. Although a lot of theoretical work on Technical Debt has been recently produced, its practical management lacks empirical studies. In this paper we investigate the state of practice in several companies in order to understand how they start tracking Technical Debt. We combined different methodologies: we conducted a survey, involving 226 respondents from 15 organizations and a more in-depth multiple case-study in three organizations, where Technical Debt was tracked: we involved 13 interviews and 79 Technical Debt issues analysis. We found that the development time dedicated to manage Technical Debt is substantial (around 25% of the overall development) but not systematic: only a few participants methodically track Technical Debt. By studying the approaches in the companies participating in the case-study, we understood how companies start tracking Technical Debt and what are the initial benefits and challenges. Finally, we propose a Strategic Adoption Model based to define and adopt a dedicated process for tracking Technical Debt."
107,2016,Technical debt indexes provided by tools: a preliminary discussion,"In software maintenance and evolution, it is important to assess both code and architecture in order to identify issues to be solved to improve software quality. Different tools provide some kind of index giving us an overall evaluation of a project to be used when managing its technical debt. In this paper, we outline how the indexes, that we call in general Technical Debt Indexes, provided by five different tools are computed. We describe their principal features and differences, what aspects they are missing, and we outline if (and how) the indexes take into account architectural problems that could have a major impact on the architectural debt. We show that the indexes rely on different information sources and measure different quantities."
109,2016,Tool support for evaluating architectural debt of an existing system: An experience report,"During software development, maintenance and evolution, we can assess the quality of code, design and architecture to capture hints of possible problems and face them as soon as possible. We can capture signals of architecture erosion in different ways by exploiting several tools with the aim to identify architectural violations, architectural smells or other relevant features. In this paper, we provide our experience report in using three known tools to capture information that can be useful to identify and evaluate the architectural debt of an application. We outline the main differences among these tools and the results they produce."
110,2016,Data mining for software engineering and humans in the loop,"The field of data mining for software engineering has been growing over the last decade. This field is concerned with the use of data mining to provide useful insights into how to improve software engineering processes and software itself, supporting decision-making. For that, data produced by software engineering processes and products during and after software development are used. Despite promising results, there is frequently a lack of discussion on the role of software engineering practitioners amidst the data mining approaches. This makes adoption of data mining by software engineering practitioners difficult. Moreover, the fact that experts’ knowledge is frequently ignored by data mining approaches, together with the lack of transparency of such approaches, can hinder the acceptability of data mining by software engineering practitioners. To overcome these problems, this position paper provides a discussion of the role of software engineering experts when adopting data mining approaches. It also argues that this role can be extended to increase experts’ involvement in the process of building data mining models. We believe that such extended involvement is not only likely to increase software engineers’ acceptability of the resulting models, but also improve the models themselves. We also provide some recommendations aimed at increasing the success of experts involvement and model acceptability."
111,2016,Software architects in large-scale distributed projects: An Ericsson case study,"Software architects are key assets for successful development projects. However, not much research has investigated the challenges they face in large-scale distributed projects. So, researchers investigated how architects at Ericsson were organized, their roles and responsibilities, and the effort they spent guarding and governing a large-scale legacy product developed by teams at multiple locations. Despite recent trends such as microservices and agile development, Ericsson had to follow a more centralized approach to deal with the challenges of scale, distribution, and monolithic architecture of a legacy software product. So, the architectural decisions were centralized to a team of architects. The team extensively used code reviews to not only check the code's state but also reveal defects that could turn into maintainability problems. The study results also suggest that the effort architects spend designing architecture, guarding its integrity and evolvability, and mentoring development teams is directly related to team maturity. In addition, significant investment is needed whenever new teams and locations are onboarded."
105,2016,Estimating and quantifying the benefits of refactoring to improve a component modularity: a case study,"In recent years, research and industry's attention has been focused on maintaining a system that would both decrease time to market in the short term and assure a sustainable feature output and smooth maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it needs to be refactored. A key property of the system assuring long-term goals consists on modularity, or else the ability to decouple different components: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes. We have conducted a case study in a large company, analyzing a case of refactoring a component to achieve modularity. We report a comparative study of a refactored against a non-refactored component. We found that the modularization would be repaid in several months of development and maintenance. We present a method to calculate the effort saved by the modularization and an equation for calculating and quantifying the development and maintenance benefits of refactoring."
122,2017,Requirements volatility in software architecture design: an exploratory case study,"Requirements volatility is a major issue in software (SW) development, causing problems such as project delays and cost overruns. Even though there is a considerable amount of research related to requirement volatility, the majority of it is inclined toward project management aspects. The relationship between SW architecture design and requirements volatility has not been researched widely, even though changing requirements may for example lead to higher defect density during testing. An exploratory case study was conducted to study how requirements volatility affects SW architecture design. Fifteen semi-structured, thematic interviews were conducted in the case company, which provides the selection of software products for business customers and consumers. The research revealed the factors, such as requirements uncertainty and dynamic business environment, causing requirements volatility in the case company. The study identified the challenges that requirements volatility posed to SW architecture design, including scheduling and architectural technical debt. In addition, this study discusses means of mitigating the factors that cause requirements volatility and addressing the challenges posed by requirements volatility. SW architects are strongly influenced by requirement volatility. Thus understanding the factors causing requirements volatility as well as means to mitigate the challenges has high industrial relevance."
118,2017,Preventing Erosion in Exception Handling Design Using Static-Architecture Conformance Checking,"Exception handling is a common error recovery technique employed to improve software robustness. However, studies have reported that exception handling is commonly neglected by developers and is the least understood and documented part of a software project. The lack of documentation and difficulty in understanding the exception handling design can lead developers to violate important design decisions, triggering an erosion process in the exception handling design. Architectural conformance checking provides means to control the architectural erosion by periodically checking if the actual architecture is consistent with the planned one. Nevertheless, available approaches do not provide a proper support for exception handling conformance checking. To fulfill this gap, we propose ArCatch: an architectural conformance checking solution to deal with the exception handling design erosion. ArCatch provides: (i) a declarative language for expressing design constraints regarding exception handling; and (ii) a design rule checker to automatically verify the exception handling conformance. To evaluate the usefulness and effectiveness of our approach, we conducted a case study, in which we evaluated an evolution scenario composed by 10 versions of an existing web-based Java system. Each version was checked against the same set of exception handling design rules. Based on the results and the feedback given by the system’s architect, the ArCatch proved useful and effective in the identification of existing exception handling erosion problems and locating its causes in the source code."
119,2017,Revealing social debt with the CAFFEA framework: An antidote to architectural debt,"Large software companies need a well-managed Software Architecture to support continuous and fast delivery of customer value both in the short and long term. However, this can be hindered if both evolution and maintenance of existing systems are hampered by Architectural Technical Debt. To avoid the accumulation and the costly consequences of ATD, it is critical that the responsibilities to minimize it are well understood and shared in a large software organization. In this paper, we argue that an organizational model, based on a well validated framework such as CAFFEA, can be used to reveal sub-optimalities in the social structure of the organization: in other words, it can reveal Social Debt. Such sub-optimality, according to previous work, leads to the accumulation of ATD. In conclusion, using the CAFFEA framework as an organizational analysis tool, can reveal weak spots (Social Debt) in the organization and can help preventing costly ATD and its consequences."
120,2017,Estimating Architectural Technical Debt: A design research,"Technical debt(TD) and the sub-category architectural technical debt (ATD) are two software related buzzwords frequently used in both academia and in the software industry. The purpose of these terms is to make it easier to understand that a software decision might lead to an expected or unexpected consequence that could have an impact in the long-run. Hence, the TD level in a project needs to be under control. However, the common approach towards refactoring of a TD is to handle it when it is too late and a crisis has emerged due to its presence. In order to solve this and make the stakeholders able to determine when a TD should be refactored a tool has been developed. This tool incorporates the newly developed AnaConDebt model, which is an ATD refactoring decision model. The outcome from building and evaluating this proof-of-concept is that there is potential for such a tool but it is not yet there. The underlying model needs to be further developed incorporating more info used by the industry."
121,2017,Using Naming Patterns for Identifying Architectural Technical Debt,"Hasty software development can produce immediate implementations with source code unnecessarily complex and hardly readable. These small kinds of software decay generate a technical debt that could be big enough to seriously affect future maintenance activities. This work presents an analysis technique for identifying architectural technical debt related to non-uniformity of naming patterns; the technique is based on term frequency over package hierarchies. The proposal has been evaluated on projects of two popular organizations, Apache and Eclipse. The results have shown that most of the projects have frequent occurrences of the proposed naming patterns, and using a graph model and aggregated data could enable the elaboration of simple queries for debt identification. The technique has features that favor its applicability on emergent architectures and agile software development"
130,2017,On the interest of architectural technical debt: Uncovering the contagious debt phenomenon,"A known problem in large software companies is to balance the prioritization of short-term and long-term business goals. As an example, architecture suboptimality (Architectural Technical Debt), incurred to deliver fast, might hinder future feature development. However, some technical debt generates more interest to be paid than other. We conducted a multi-phase, multiple-case embedded case study comprehending 9 sites at 6 large international software companies. We have investigated which architectural technical debt items generate more interest , how the interest occurs during software development and which costly extra-activities are triggered as a result. We presented a taxonomy of the most dangerous items identified during the qualitative investigation and a model of their effects that can be used for prioritization, for further investigation and as a quality model for extracting more precise and context-specific metrics. We found that some architectural technical debt items are contagious, causing the interest to be not only fixed, but potentially compound, which leads to the hidden growth of interest (possibly exponential). We found important factors to be monitored to refactor the debt before it becomes too costly. Instances of these phenomena need to be identified and stopped before the development reaches a crises."
128,2017,The Pricey Bill of Technical Debt: When and by Whom will it be Paid?,"Software companies need to support continuous and fast delivery of customer value both in short and a long-term perspective. However, this can be hindered by evolution limitations and high maintenance efforts due to internal software quality issues by what is described as Technical Debt. Although significant theoretical work has been undertaken to describe the negative effects of Technical Debt, these studies tend to have a weak empirical basis and often lack quantitative data. The aim of this study is to estimate wasted time, caused by the Technical Debt interest during the software life-cycle. This study also investigates how practitioners perceive and estimate the impact of the negative consequences due to Technical Debt during the software development process. This paper reports the results of both an online web-survey provided quantitative data from 258 participants and follow-up interviews with 32 industrial software practitioners. The importance and originality of this study contributes and provides novel insights into the research on Technical Debt by quantifying the perceived interest and the negative effects it has on the software development life-cycle. The findings show that on average, 36 percent of all development time is estimated to be wasted due to Technical Debt; Complex Architectural Design and Requirement Technical Debt generates most negative effect; and that most time is wasted on understanding and/or measuring the Technical Debt. Moreover, the analysis of the professional roles and the age of the software system in the survey revealed that different roles are affected differently and that the consequences of Technical Debt are also influenced by the age of the software system."
125,2017,Taxonomies in software engineering: A systematic mapping study and a revised taxonomy development method,"Context: Software Engineering (SE) is an evolving discipline with new subareas being continuously developed and added. To structure and better understand the SE body of knowledge, taxonomies have been proposed in all SE knowledge areas. Objective: The objective of this paper is to characterize the state-of-the-art research on SE taxonomies. Method: A systematic mapping study was conducted, based on 270 primary studies. Results: An increasing number of SE taxonomies have been published since 2000 in a broad range of venues, including the top SE journals and conferences. The majority of taxonomies can be grouped into the following SWEBOK knowledge areas: construction (19.55%), design (19.55%), requirements (15.50%) and maintenance (11.81%). Illustration (45.76%) is the most frequently used approach for taxonomy validation. Hierarchy (53.14%) and faceted analysis (39.48%) are the most frequently used classification structures. Most taxonomies rely on qualitative procedures to classify subject matter instances, but in most cases (86.53%) these procedures are not described in sufficient detail. The majority of the taxonomies (97%) target unique subject matters and many taxonomy-papers are cited frequently. Most SE taxonomies are designed in an ad-hoc way. To address this issue, we have revised an existing method for developing taxonomies in a more systematic way. Conclusion: There is a strong interest in taxonomies in SE, but few taxonomies are extended or revised. Taxonomy design decisions regarding the used classification structures, procedures and descriptive bases are usually not well described and motivated."
126,2017,Impact of architectural technical debt on daily software development work—a survey of software practitioners,"The negative consequences of Technical Debt is an area of increasing interest, and more specifically the Architectural aspects of it have received increased attention in the last few years. Besides the negative effects of Architectural Technical Debt on the overall software product quality in terms of hindering evolution and causing high maintenance costs, Architectural Technical Debt also has a significant negative impact on software practitioners' daily work. Although a great deal of theoretical work on Architectural Technical Debt has been undertaken, there is a lack of empirical studies that examine the negative effects of Architectural Technical Debt during the software development lifecycle. The aim of this study is to investigate how practitioners perceive and estimate the impact of Architectural Technical Debt during the software development process. This paper reports the results of an online web survey providing quantitative data from 258 participants. The contribution of this paper is threefold: First, it shows that practitioners experience that the Architectural type of Technical Debt has the highest negative impact on daily software development work. Secondly, we provide evidence that does not support the commonly held belief that Architectural Technical Debt increases with the age of the software. Thirdly, we show that despite different responsibilities and working tasks of software professionals, Architectural Technical Debt negatively affects all roles without any significant difference between the roles."
129,2017,Managing the requirements flow from strategy to release in large-scale agile development: a case study at Ericsson,"In a large organization, informal communication and simple backlogs are not sufficient for the management of requirements and development work. Many large organizations are struggling to successfully adopt agile methods, but there is still little scientific knowledge on requirements management in large-scale agile development organizations. We present an in-depth study of an Ericsson telecommunications node development organization which employs a large scale agile method to develop telecommunications system software. We describe how the requirements flow from strategy to release, and related benefits and problems. Data was collected by 43 interviews, which were analyzed qualitatively. The requirements management was done in three different processes, each of which had a different process model, purpose and planning horizon. The release project management process was plan-driven, feature development process was continuous and implementation management process was agile. The perceived benefits included reduced development lead time, increased flexibility, increased planning efficiency, increased developer motivation and improved communication effectiveness. The recognized problems included difficulties in balancing planning effort, overcommitment, insufficient understanding of the development team autonomy, defining the product owner role, balancing team specialization, organizing system-level work and growing technical debt. The study indicates that agile development methods can be successfully employed in organizations where the higher level planning processes are not agile. Combining agile methods with a flexible feature development process can bring many benefits, but large-scale software development seems to require specialist roles and significant coordination effort. © 2016, The Author(s)."
124,2017,Risk Appetite in Architectural Decision-Making,"This paper is an exploratory study on architects' attitudes towards risk and its influences on the architectural decision-making process. A classification of architects' attitude to risk-taking has been developed on the basis of Fowler's Technical Debt Quadrants. The core proposition of the paper is that the well-established concept of `risk appetite' can be equally well applied to characterise and classify architects' attitudes towards risk. This enables the aspects of the decision-making process that are influenced by architects' attitudes towards risks to be identified, and reveals what these influences are. It has been shown that the proposed classifications reflect many real-world situations."
127,2017,An Open Tool for Assisting in Technical Debt Management,"Technical debt monitoring is one of the activities that have to be performed in technical debt management. To do that, there are different techniques that can be used to estimate technical debt and different tools that implement those different techniques. This paper presents TEDMA Tool, a tool for monitoring technical debt over the software evolution and that it is open to integrate third party tools. TEDMA is based on the analysis of source code repositories and is useful for researching using empirical data extracted from software projects. Currently, it is been used to analyze big projects in the execution of several case studies. The expected evolution of TEDMA will make the tool useful for software development industry."
123,2017,Compiling static software metrics for reliability and maintainability from GitHub repositories,"this paper identifies a small, essential set of static software code metrics linked to the software product quality characteristics of reliability and maintainability and to the most commonly identified sources of technical debt. A plug-in is created for the Understand code visualization and static analysis tool that calculates and aggregates the metrics. The plug-in produces a high-level interactive html report as well as developer-level information needed to address quality issues using Understand. A script makes use of Git, Understand, and the plug-in to compile results for a list of GitHub repositories into a single file. The primary contribution of this work is to describe an open-source plug-in to measure and visualize architectural complexity based on the propagation cost and core size metrics, which are not currently found in other tools. The plug-in should be useful to researchers and practitioners interested in these two metrics and as an expedient starting point to experimentation with metric collection and aggregation for groups of GitHub repositories. The plug-in was developed as a first step in an ongoing project aimed at applying case-based reasoning to the issue of software product quality."
135,2018,Architectural technical debt identification: The research landscape,"Architectural Technical Debt (ATD) regards sub-optimal design decisions that bring short-term benefits to the cost of long-term gradual deterioration of the quality of the architecture of a software system. The identification of ATD strongly in uences the technical and economic sustainability of software systems and is attracting growing interest in the scientific community. During the years several approaches for ATD identification have been conceived, each of them addressing ATD from diferent perspectives and with heterogeneous characteristics. In this paper we apply the systematic mapping study methodology for identifying, classifying, and evaluating the state of the art on ATD identification from the following three perspectives: publication trends, characteristics, and potential for industrial adoption. Specically, starting from a set of 509 potentially relevant studies, we systematically selected 47 primary studies and analyzed them according to a rigorously-de ned classification framework. The analysis of the obtained results supports both researchers and practitioners by providing (i) an assessment of current research trends and gaps in ATD identification, (ii) a solid foundation for understanding existing (and future) research on ATD identification, and (iii) a rigorous evaluation of its potential for industrial adoption."
136,2018,Managing architectural technical debt: A unified model and systematic literature review,"Large Software Companies need to support the continuous and fast delivery of customer value in both the short and long term. However, this can be impeded if the evolution and maintenance of existing systems is hampered by what has been recently termed Technical Debt (TD). Specifically, Architectural TD has re- ceived increased attention in the last few years due to its significant impact on system success and, left unchecked, it can cause expensive repercussions. It is therefore important to understand the underlying factors of architectural TD. With this as background, there is a need for a descriptive model to illustrate and explain different architectural TD issues. The aim of this study is to synthesize and compile research efforts with the goal of creating new knowledge with a specific interest in the architectural TD field. The contribution of this paper is the presentation of a novel descriptive model, providing a comprehensive interpretation of the architectural TD phenomenon. This model categorizes the main characteristics of architectural TD and reveals their relations. The results show that, by using this model, different stake- holders could increase the system’s success rate, and lower the rate of negative consequences, by raising awareness about architectural TD."
134,2018,Anacondebt: A tool to assess and track technical debt,"It is challenging to assess and manage Technical Debt. Technical Debt is avoided or refactored if the long-term bene ts, such as preventing extra-costs, exceed the cost of repaying the debt. Some tools have been recently proposed for the identification of Technical Debt, but most of them do not help in assessing the cost-bene ts of repaying the Debt. Besides, it is challenging to track, visualize and plan Technical Debt refactoring systematically. Although practitioners might use simple tracking tools, calculating and communicating Technical Debt is currently not supported. Based on the results of previous research, combined with several practical experiences in collaboration with large software companies, we have developed and evaluated a lightweight tool, AnaCon-Debt, to track and assess Technical Debt."
137,2018,An architectural smells detection tool for c and c++ projects,"Architectural smells gained great attention in the past few years since they directly affect software quality and increase architectural technical debt. However, while it is straightforward to understand why they are important, it is more difficult to find techniques and tools to detect and remove architectural smells. The purpose of this paper is to introduce an open-source tool for automatic architectural smells detection for C/C++ projects, by creating an abstraction of the project and defining the concept of dependency between elements belonging to the project in order to identify architectural smells. The tool has been validated on some open-source projects with promising results."
132,2018,A Case Study of the Effects of Architecture Debt on Software Evolution Effort,"In large-scale software systems, the majority of defective files are architecturally connected, and the architecture connections usually exhibit design flaws, which are associated with higher change-proneness among files and higher maintenance costs. As software evolves with bug fixes, new features, or improvements, unresolved architecture design flaws can contribute to maintenance difficulties. The impact on effort due to architecture design flaws has been difficult to quantify and justify. In this paper, we conducted a case study where we identified flawed architecture relations and quantified their effects on maintenance activities. Using data from this project's source code and revision history, we identified file groups where files are architecturally connected and participated in flawed architecture designs, quantified the maintenance activities in the detected files, and assessed the penalty related to these files."
131,2018,Limiting technical debt with maintainability assurance: an industry survey on used techniques and differences with service-and microservice-based systems,"Maintainability assurance techniques are used to control this quality attribute and limit the accumulation of potentially unknown technical debt. Since the industry state of practice and especially the handling of Service- and Microservice-Based Systems in this regard are not well covered in scientific literature, we created a survey to gather evidence for a) used processes, tools, and metrics in the industry, b) maintainability-related treatment of systems based on service-orientation, and c) influences on developer satisfaction w.r.t. maintainability. 60 software professionals responded to our online questionnaire. The results indicate that using explicit and systematic techniques has benefits for maintainability. The more sophisticated the applied methods the more satisfied participants were with the maintainability of their software while no link to a hindrance in productivity could be established. Other important findings were the absence of architecture-level evolvability control mechanisms as well as a significant neglect of service-oriented particularities for quality assurance. The results suggest that industry has to improve its quality control in these regards to avoid problems with long-living service-based software systems."
138,2018,A position study to investigate technical debt associated with security weaknesses,"Context: Managing technical debt (TD) associated with potential security breaches found during design can lead to catching vulnerabilities (i.e., exploitable weaknesses) earlier in the software lifecycle; thus, anticipating TD principal and interest that can have decidedly negative impacts on businesses. Goal: To establish an approach to help assess TD associated with security weaknesses by leveraging the Common Weakness Enumeration (CWE) and its scoring mechanism, the Common Weakness Scoring System (CWSS). Method: We present a position study with a five-step approach employing the Quamoco quality model to operationalize the scoring of architectural CWEs. Results: We use static analysis to detect design level CWEs, calculate their CWSS scores, and provide a relative ranking of weaknesses that help practitioners identify the highest risks in an organization with a potential to impact TD. Conclusion: CWSS is a community agreed upon method that should be leveraged to help inform the ranking of security related TD items."
133,2018,Towards an architectural debt index,"Different indexes have been proposed to evaluate software quality and technical debt. Usually these indexes take into account different code level issues and several metrics, well known software metrics or new ones defined ad hoc for a specific purpose. In this paper we propose and define a new index, more oriented to the evaluation of architectural violations. We describe in detail the index, called Architectural Debt Index, that we integrated in a tool developed for architectural smell detection. The index is based on the detection of architectural smells, their criticality and their history. Currently only dependency architectural smells have been considered, but other architectural debt indicators can be considered and integrated in the index computation."
140,2018,Investigating the causes of software technical debt at the architectural level,"Architectural technical debt (ATD) describes the consequences of intentionally or unintentionally making architectural design decisions that compromise the internal quality of a software system. These consequences include long-term software evolution and maintenance issues that jeopardize software developer productivity. The architectural aspect of technical debt has been receiving significant interest from technical debt researchers, but many questions concerning architectural technical debt itself have yet to be answered. The main goal of this exploratory multiple-case study is to investigate architectural technical debt’s causes and accumulations at the design decision-level by examining software practitioners’ experiences with architectural technical debt and creating taxonomies that would aid software practitioners and technical debt researchers in the future. We conducted semi-structured interviews with 18 participants and an interview-style online questionnaire with 10"
147,2018,How do developers fix issues and pay back technical debt in the Apache ecosystem?,"During software evolution technical debt (TD) follows a constant ebb and flow, being incurred and paid back, sometimes in the same day and sometimes ten years later. There have been several studies in the literature investigating how technical debt in source code accumulates during time and the consequences of this accumulation for software maintenance. However, to the best of our knowledge there are no large scale studies that focus on the types of issues that are fixed and the amount of TD that is paid back during software evolution. In this paper we present the results of a case study, in which we analyzed the evolution of fifty-seven Java open-source software projects by the Apache Software Foundation at the temporal granularity level of weekly snapshots. In particular, we focus on the amount of technical debt that is paid back and the types of issues that are fixed. The findings reveal that a small subset of all issue types is responsible for the largest percentage of TD repayment and thus, targeting particular violations the development team can achieve higher benefits."
141,2018,Identifying and prioritizing architectural debt through architectural smells: a case study in a large software company,"Architectural technical debt can have a huge impact on software maintainability and evolution. Hence, different architectural violations, detected as architectural smells, need to be identified and refactored. In this paper, we conducted a multiple case-study on several architectural smells detected in four industrial projects. We conducted an in-depth investigation with a questionnaire, interviews and thorough inspection of the code with the practitioners. We evaluated the negative impact of the technical debt detected by the architectural smells, their difficulty to be refactored and the usefulness of the detection tool. The results show that practitioners appreciated the help of automatic detection, and that they prioritize refactoring architectural debt that causes more negative impact despite the higher refactoring effort."
142,2018,Effort estimation in large-scale software development: An industrial case study,"Context: Software projects frequently incur schedule and budget overruns. Planning and estimation are particularly challenging in large and globally distributed agile projects. While software engineering researchers have been investigating effort estimation for many years to help practitioners to improve their estimation processes, there is little empirical research about effort estimation in large-scale distributed projects involving agile teams. Objective: The objective of this paper is three-fold: i) To identify how effort estimation is carried out in large-scale distributed agile projects; ii) to analyze the accuracy of the effort estimation processes in large-scale distributed agile projects; and iii) to identify and investigate the factors that impact the accuracy of effort estimates in large-scale distributed agile projects. Method: We performed an exploratory longitudinal case study. The data collection was operationalized through archival research and semi-structured interviews. Results: The main findings of the studied case are: 1) A two-stage estimation process, with re-estimation at the analysis stage, improves the accuracy of the effort estimates; 2) underestimation is the dominant trend; 3) less mature teams incur larger effort overruns; 4) requirements with larger size/scope incur larger effort overruns; 5) requirements developed in multi-site settings incur larger effort overruns as compared to requirements developed in a co-located setting; 6) requirements priorities impact the accuracy of the effort estimates. Conclusion: A two-stage effort estimation process can improve effort estimation accuracy and seems to address some of the challenges in large-scale agile software development. To improve effort estimates one needs to consider team maturity, distribution as well as requirements size and priorities."
143,2018,A semi-automated framework for the identification and estimation of architectural technical debt: A comparative case-study on the modularization of a software component,"Context Research and industry's attention has been focusing on developing systems that enable fast time to market in the short term, but would assure a sustainable delivery of business value and maintenance operations in the long run. A related phenomenon has been identified in Architectural Technical Debt: if the system architecture is sub-optimal for long-term business goals, it might need to be refactored. A key property of the system assuring long-term goals is its modularity, or else the degree to which components are decoupled: such property allows the product to be evolved without costly changes pervading the whole system. However, understanding the business benefits of refactoring to achieve modularity is not trivial, especially for large refactorings involving substantial architectural changes. Objective The aim of this study was to develop a technique to identify Architectural Technical Debt in the form of a non-modularized component and to quantify the convenience of its repayment. Method We have conducted a single, embedded case study in a large company, comparing a component before and after it was refactored to achieve modularity. We have developed a holistic framework for the semi-automated identification and estimation of Architectural Technical Debt in the form of non-modularized components. We then evaluate the technique reporting a comparative study of the difference in maintenance and development costs in two coexisting systems, one including the refactored component and one including the non-refactored one. Results The main contributions are a measurement system for the identification of the Architectural Technical Debt according to the stakeholders’ goals, a mathematical relationship for calculating and quantifying its interest in terms of extra-effort spent in additional development and maintenance, and an overall decision framework to assess the benefit of refactoring. We also report context-specific results that show the estimated benefits of refactoring the specific case of Architectural Technical Debt. Conclusion We found that it is possible to identify this kind of Architectural Technical Debt and to quantify its repayment convenience. Thanks to the developed framework, it was possible to estimate that the Architectural Technical Debt present in the component was causing substantial continuous extra-effort, and that the modularization would be repaid in several months of development and maintenance."
144,2018,Identifying architectural technical debt in android applications through automated compliance checking,"By considering the fast pace at which mobile applications need to evolve, Architectural Technical Debt results to be a crucial yet implicit factor of success. In this research we present an approach to automatically identify Architectural Technical Debt in Android applications. The approach takes advantage of architectural guidelines extraction and modeling, architecture reverse engineering, and compliance checking. As future work, we plan to fully automate the process and empirically evaluate it via large-scale experiments."
145,2018,"A tertiary study on technical debt: Types, management strategies, research trends, and base information for practitioners","Context The concept of technical debt (TD) contextualizes problems faced during software evolution considering the tasks that are not carried out adequately during its development. Currently, it is common to associate any impediment related to the software product and its development process to the definition of TD. This can bring confusion and ambiguity in the use of the term. Besides, due to the increasing amount of work in the area, it is difficult to have a comprehensive view of the plethora of proposals on TD management. Objective This paper intends to investigate the current state of research on TD by identifying what research topics have been considered, organizing research directions and practical knowledge that has already been defined, identifying the known types of TD, and organizing what activities, strategies and tools have been proposed to support the management of TD. Method A tertiary study was performed based on a set of five research questions. In total, 13 secondary studies, dated from 2012 to March 2018, were evaluated. Results The results of this tertiary study are beneficial for both practitioners and researchers. We evolved a taxonomy of TD types, identified a list of situations in which debt items can be found in software projects, and organized a map representing the state of the art of activities, strategies and tools to support TD management. Besides, we also summarized some research directions and practical knowledge, and identified the research topics that have been more considered in secondary studies. Conclusion This tertiary study revisited the TD landscape. Its results can help to identify points that still require further investigation in TD research."
146,2018,Design rule spaces: A new model for representing and analyzing software architecture,"In this paper, we propose an architecture model called Design Rule Space (DRSpace). We model the architecture of a software system as multiple overlapping DRSpaces, reflecting the fact that any complex software system must contain multiple aspects, features, patterns, etc. We show that this model provides new ways to analyze software quality. In particular, we introduce an Architecture Root detection algorithm that captures DRSpaces containing large numbers of a project's bug-prone files, which are called Architecture Roots (ArchRoots). After investigating ArchRoots calculated from 15 open source projects, the following observations become clear: from 35 to 91 percent of a project's most bug-prone files can be captured by just 5 ArchRoots, meaning that bug-prone files are likely to be architecturally connected. Furthermore, these ArchRoots tend to live in the system for significant periods of time, serving as the major source of bug-proneness and high maintainability costs. Moreover, each ArchRoot reveals multiple architectural flaws that propagate bugs among files and this will incur high maintenance costs over time. The implication of our study is that the quality, in terms of bug-proneness, of a large, complex software project cannot be fundamentally improved without first fixing its architectural flaws."
139,2018,An Empirical Investigation of the Harmfulness of Architectural Technical Debt,"Background: In order to survive in today's fast-growing and ever fast-changing business environments, large-scale software companies need to deliver customer value continuously, both from a short- and long-term perspective. However, the consequences of potential long-term and far-reaching negative effects of shortcuts and quick fixes made during the software development lifecycle, described as Technical Debt (TD), can impede the software development process.
Objective: The overall goal of this Licentiate thesis is to empirically study and understand in what way and to what extent, TD in general and architectural TD specifically, influence today’s software development work and, specifically, with the intention of providing more quantitative insights into the field.
Method: To achieve the objectives, a combination of both quantitative and qualitative research methodologies are used, including interviews, surveys, a systematic literature review, a longitudinal study, correlation analysis, and statistical tests. In five of the seven included studies, we use a combination of multiple research methods to achieve high validity.
Results: We present results showing that software suffering from TD will cause various different negative effects on both the software and on the developing process. These negative effects can be illustrated from a technical, a financial and from a developer’s working situational perspective.
Conclusion: This thesis contributes to the understanding and quantification of in what way and to what extent TD is harmful to software development organizations. The results show that software practitioners estimate that they waste 36% of their working time due to experiencing TD and that the TD is causing them to perform additional time- consuming work activities. This study also shows that, compared to all types of TD, architectural TD has the greatest negative impact on the daily software development work."
148,2018,Exploring the relationship between software modularity and technical debt,"Modularity is one of the key principles of software design. In order for a software system to be modular, it should be organized into modules that are highly coherent internally, whereas at the same time as independent from other modules as possible. In this paper we explore coupling and cohesion metrics at the software package level-i.e., one of most basic levels of software functional decomposition in object-oriented (OO) systems, with the aim of investigating their relation to the technical debt of each package. Current state-of-the-art tools in TD measurement are working on the source code level, and the extent to which they can unveil limitations at the architecture level (e.g., violations of the modularity principle), has not been explored so far. To achieve this goal, we conducted a case study on 1,200 packages retrieved from 20 well-known open source software projects. The results of the study suggested that current measures of technical debt are able to identify / predict modules that lack modularity, and therefore suffer from Architectural Technical Debt (ATD). The results of the study are discussed both from the practitioners' and re-searchers' point of view."
149,2018,Exploring multilateral Cloud computing security architectural design debt in terms of technical debt,"This work identifies various design debt causes in a cloud computing system from various dimensions of design debt. Even though immature, un-ripen coded service accessible over the Internet using the cloud computing paradigm may work fine and be wholly tolerable to the patron; but excess quantities will make a service progression that may lead to extreme specialist of software developers and finally an inflexible product. Delivery of the earliest primary beginning coded service without ripeness or maturity is like going into debts or arrears or due to obligation. A petite tiny debt rates progress so protracted as it is paid or rewarded back punctually with a rewrite/redraft/revising/reworking. The risk arises when the debt is not repaid and settled. Every miniature infinitesimal effort spent on imprecise code reckons as interest on that arrears/debt. Intact engineering business can be brought to be idle under the balance load of an unconsolidated, non-solicit implementation, execution, and performance discharging object-oriented, functional or procedural or otherwise. This work uses refactoring as a solution for the identified debt in the multilateral cloud security architecture to secure the cloud services."
156,2019,Assuring the evolvability of microservices: insights into industry practices and challenges,"While Microservices promise several beneficial characteristics for sustainable long-term software evolution, little empirical research covers what concrete activities industry applies for the evolvability assurance of Microservices and how technical debt is handled in such systems. Since insights into the current state of practice are very important for researchers, we performed a qualitative interview study to explore applied evolvability assurance processes, the usage of tools, metrics, and patterns, as well as participants' reflections on the topic. In 17 semi-structured interviews, we discussed 14 different Microservice-based systems with software professionals from 10 companies and how the sustainable evolution of these systems was ensured. Interview transcripts were analyzed with a detailed coding system and the constant comparison method. We found that especially systems for external customers relied on central governance for the assurance. Participants saw guidelines like architectural principles as important to ensure a base consistency for evolvability. Interviewees also valued manual activities like code review, even though automation and tool support was described as very important. Source code quality was the primary target for the usage of tools and metrics. Despite most reported issues being related to Architectural Technical Debt (ATD), our participants did not apply any architectural or service-oriented tools and metrics. While participants generally saw their Microservices as evolvable, service cutting and finding an appropriate service granularity with low coupling and high cohesion were reported as challenging. Future Microservices research in the areas of evolution and technical debt should take these findings and industry sentiments into account."
155,2019,DV8: automated architecture analysis tool suites,"This paper present our tool suite called DV8. The objective of DV8 is to measure software modularity, detect architecture anti-patterns as technical debts, quantify the maintenance cost of each instance of an anti-pattern, and enable return on investment analyses of architectural debts. Different from other tools, DV8 integrates data from both source code and revision history. We now elaborate on each of DV8's capabilities."
154,2019,Is self-admitted technical debt a good indicator of architectural divergences?,"Large software systems tend to be highly complex and often contain unaddressed issues that evolve from bad design practices or architectural implementations that drift from definition. These design flaws can originate from quick fixes, hacks or shortcuts to a solution, hence they can be seen as Technical Debt. Recently, new work has focused on studying source code comments that indicate Technical Debt, i.e., Self-Admitted Technical Debt (SATD). However, it is not known if addressing information left by developers in the form source code comments can give insight about the design flaws in a system and have the potential to provide fixes for bad architectural implementations. This paper investigates the possibility of using SATD comments to resolve architectural divergences. We leverage a data set of previously classified SATD comments to trace them to the architectural divergences of a large open source system, namely ArgoUML. We extract its conceptual and concrete architectures based on available design documentation and source code, and contrast both to expose divergences, trace them to SATD comments, and investigate their resolution. We found 7 high-level divergences in ArgoUML and 22 others among its subsystems, observing that merely 4 out of 29 (14%) divergences can be directly traced to SATD. Although using SATD as an indicator of architectural divergences is viable, the effort of doing so is time-intensive, and in general, will not lend to a significant reduction of architectural flaws in a software system."
153,2019,Evolution of the Unix system architecture: an exploratory case study,"Unix has evolved for almost five decades, shaping modern operating systems, key software technologies, and development practices. Studying the evolution of this remarkable system from an architectural perspective can provide insights on how to manage the growth of large, complex, and long-lived software systems. Along main Unix releases leading to the FreeBSD lineage we examine core architectural design decisions, the number of features, and code complexity, based on the analysis of source code, reference documentation, and related publications. We report that the growth in size has been uniform, with some notable outliers, while cyclomatic complexity has been religiously safeguarded. A large number of Unix-defining design decisions were implemented right from the very early beginning, with most of them still playing a major role. Unix continues to evolve from an architectural perspective, but the rate of architectural innovation has slowed down over the system's lifetime. Architectural technical debt has accrued in the forms of functionality duplication and unused facilities, but in terms of cyclomatic complexity it is systematically being paid back through what appears to be a self-correcting process. Some unsung architectural forces that shaped Unix are the emphasis on conventions over rigid enforcement, the drive for portability, a sophisticated ecosystem of other operating systems and development organizations, and the emergence of a federated architecture, often through the adoption of third-party subsystems. These findings have led us to form an initial theory on the architecture evolution of large, complex operating system software."
157,2019,Managing Technical Debt: Reducing Friction in Software Development,
151,2019,Investigating instability architectural smells evolution: an exploratory case study,"Architectural smells may substantially increase maintenance effort and thus require extra attention for potential refactoring. While we currently understand this concept and have identified different types of such smells, we have not yet studied their evolution in depth. This is necessary to inform their prioritisation and refactoring. This study analyses the evolution of individual architectural smell instances over time, and the characteristics that define these instances. Three different types of architectural smells are taken into consideration and mined from a total of 524 versions across 14 different projects. The results show how different smell types differ in multiple aspects, such as their growth rate, the importance of the affected elements over time in the dependency network of the system, and the time each instance affects the system. They also cast valuable insights on what aspects are the most important to consider during prioritisation and refactoring activities."
150,2019,Applying Social Network Analysis Techniques to Architectural Smell Prediction,"As a software system evolves, the amount and complexity of the interactions amongst its components is likely to increase, which negatively affects the system design structure and also its quality. For instance, certain modules might become coupled due to a new user feature being added or to suboptimal development decisions. Design degradation symptoms are often related to high coupling and unwanted dependencies, such as: cyclic dependencies or violations to design rules, amongst other architectural smells. Thus, the early detection of such symptoms is important for architects to: i) anticipate dependency-related design problems in different parts of the system, ii) assess possible situations of technical debt, and iii) proactively look for solutions to preserve the quality of the system. Although there are approaches that analyse design dependencies in code bases and flag smell occurrences, very few of them have dealt with the prediction of dependency relations amongst software components. This research hypothesises that a predictive approach can warn architects about dependency-related problems before they appear. To this end, a particular graph-based approach is social networks analysis (SNA), which has been used for modelling both nature and human phenomena. Specifically, SNA techniques can predict links that do not yet exist between pairs of nodes in a network. SNA applications have shown evidence that the topological features of dependency graphs can reveal interesting properties of the software system under analysis. Nonetheless, SNA techniques have not yet been extensively exploited in the Software Architecture community. In this context, the question that motivates this research is to what extent SNA can leverage on information from a software design (and its evolution over time) for inferring new dependencies and likely configurations of architectural smells out of those dependencies."
169,2019,Architectural technical debt in microservices: a case study in a large company,"Introduction: Software companies aim to achieve continuous delivery to constantly provide value to their customers. A popular strategy is to use microservices architecture. However, such an architecture is also subject to debt, which hinders the continuous delivery process and thus negatively affects the software released to the customers. Objectives: The aim of this study is to identify issues, solutions and risks related to Architecture Technical Debt in microservices. Method: We conducted an exploratory case study of a real life project with about 1000 services in a large, international company. Through qualitative analysis of documents and interviews, we investigated Architecture Technical Debt in the communication layer of a system with microservices architecture. Results: Our main contributions are a list of Architecture Technical Debt issues specific for the communication layer in a system with microservices architecture, as well as their associated negative impact (interest), a solution to repay the debt and the its cost (principal). Among the found Architecture Technical Debt issues were the existence of business logic in the communication layer and a high amount of point-to-point connections between services. The studied solution consists of the implementation of different canonical models specific to different domains, the removal of business logic from the communication layer, and migration from services to use the communication layer correctly. We also contributed with a list of possible risks that can affect the payment of the debt, as lack of funding and inadequate prioritization. Conclusion: We found issues, solutions and possible risks that are specific for microservices architectures not yet encountered in the current literature. Our results may be useful for practitioners that want to avoid or repay Technical Debt in their microservices architecture."
152,2019,Pagerank and criticality of architectural smells,"Architectural smells represent symptoms of problems at architectural level that can negatively impact internal software qualities and lead to architectural debt. Detecting architectural smells and identifying the most critical ones is the key to prioritize refactoring efforts and prevent software architecture erosion. In this paper we focus our attention on three architectural smells based on dependency issues, called Cyclic Dependency, Unstable Dependency, and Hub-Like Dependency. Moreover, we evaluate the PageRank and Criticality of these smells through the analysis of six projects. PageRank is a measure that estimates whether an architectural smell is located in an important part of the project, where the importance is evaluated according to how many parts of a project depend on the one involved in the architectural smell. We describe a case study on the analysis of the possible relation existing between the PageRank and Criticality of the smells. The results show how the two measures can be both used to locate the architectural smells that need particular inspections and attention."
158,2019,Active hotspot: an issue-oriented model to monitor software evolution and degradation,"Architecture degradation has a strong negative impact on software quality and can result in significant losses. Severe software degradation does not happen overnight. Software evolves continuously, through numerous issues, fixing bugs and adding new features, and architecture flaws emerge quietly and largely unnoticed until they grow in scope and significance when the system becomes difficult to maintain. Developers are largely unaware of these flaws or the accumulating debt as they are focused on their immediate tasks of address individual issues. As a consequence, the cumulative impacts of their activities, as they affect the architecture, go unnoticed. To detect these problems early and prevent them from accumulating into severe ones we propose to monitor software evolution by tracking the interactions among files revised to address issues. In particular, we propose and show how we can automatically detect active hotspots, to reveal architecture problems. We have studied hundreds of hotspots along the evolution timelines of 21 open source projects and showed that there exist just a few dominating active hotspots per project at any given time. Moreover, these dominating active hotspots persist over long time periods, and thus deserve special attention. Compared with state-of-the-art design and code smell detection tools we report that, using active hotspots, it is possible to detect signs of software degradation both earlier and more precisely."
164,2019,Architectural smells detected by tools: a catalogue proposal,"Architectural smells can negatively impact on different software qualities and can represent a relevant source of architectural debt. Several architectural smells have been defined by different researchers. Moreover, both academia and industry proposed several tools for software quality analysis, but it is not always clear to understand which tools provide also support for architectural smells detection and if the tools developed for this specific purpose are effectively available or not. In this paper we propose a catalogue of architectural smells for which, at least one tool able to detect the smell exists. We outline the main differences in the detection techniques exploited by the tools and we propose a classification of these architectural smells according to the violation of three design principles."
159,2019,A longitudinal study of identifying and paying down architecture debt,"Architecture debt is a form of technical debt that derives from the gap between the intended and the actual architecture design. In this study we measured architecture debt in two ways: 1) in terms of system-wide coupling measures, and 2) in terms of the number and severity of architecture flaws. In recent research it was shown that the amount of architecture debt has a huge impact on software maintainability and evolution. Consequently, reducing debt is expected to make software less costly and more amenable to change. This paper reports on a longitudinal study of a healthcare communications product created by BrightSquid Secure Communications Corp. This young company is facing the typical trade-off problem of desiring responsiveness to change requests, but wanting to avoid the ever-increasing effort that the accumulation of quick-and-dirty changes eventually incurs. In the first stage of the study, we analyzed the status of the ""before"" system, which showed the impacts of change requests. This initial study motivated a more in-depth analysis of architecture debt. The results of this debt analysis were used in the second stage of the work to motivate a comprehensive refactoring of the software system. The third stage was a follow-on architecture debt analysis which quantified the improvements realized. Using this quantitative evidence, augmented by qualitative evidence gathered from in-depth interviews with BrightSquid's architects, we present lessons learned about the costs and benefits of paying down architecture debt in practice."
161,2019,Technical debt triage in backlog management,"Remediation of technical debt through regular refactoring initiatives is considered vital for the software system's long and healthy life. However, since today's software companies face increasing pressure to deliver customer value continuously, the balance between spending developer time, effort, and resources on implementing new features or spending it on refactoring of technical debt becomes vital. The goal of this study is to explore how the prioritization of technical debt is carried out by practitioners within today's software industry. This study also investigates what factors influence the prioritization process and its related challenges. This paper reports the results of surveying 17 software practitioners, together with follow-up interviews with them. Our results show that there is no uniform way of prioritizing technical debt and that it is commonly done reactively without applying any explicit strategies. Often, technical debt issues are managed and prioritized in a shadow backlog, separate from the official sprint backlog. This study was also able to identify several different challenges related to prioritizing technical debt, such as the lack of quantitative information about the technical debt items and that the refactoring of technical debt issues competes with the implementation of customer requirements."
162,2019,VisminerTD: a tool for automatic identification and interactive monitoring of the evolution of technical debt items,"Technical debt (TD) contextualizes problems faced during software evolution considering the tasks that are not carried out adequately during software development. Software TD is a type of debt that brings a short-term benefit, but which may have to be paid with interest later on in the software development life cycle. Its presence brings risks to the project and can reduce its quality. It is worthwhile to have automatic mechanisms to monitor it, as TD monitoring requires the analysis of large amounts of complex data. Therefore, the combination of software metrics and code comment analysis, in the identification, and information visualization techniques, in monitoring, present themselves as a promising strategy to manage TD. This work presents VisminerTD, a tool that allows the automatic identification and interactive monitoring of the evolution of TD items by combining software metrics, code comment analysis, and information visualization. To evaluate its applicability, a feasibility study was carried out considering JUnit 4 and Apache Ant software projects. The results indicated that VisminerTD can support software development teams in monitoring TD items. In addition, a second case study was performed to assess the feasibility of the proposed tool regarding its usefulness, ease of use, and self-predicted future use. The results provided positive evidence on the use of the proposed tool, indicating (i) that it can be useful in supporting TD Identification and TD monitoring activities and (ii) that it can bring gains in terms of comprehensiveness and efficacy when evaluating the desirable time to identify and monitor different types of debt. Given the current scenario characterized by limited options of tools that combine different information to support automatic identification and monitoring of the evolution of TD items in software projects, VisminerTD can approximate the state-of-the-art and the state-of-the-practice in the TD area, contributing to a wider dissemination of the concept."
163,2019,A proposed model-driven approach to manage architectural technical debt life cycle,"Architectural Technical Debt (ATD) is a metaphor used to describe consciously decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, difficulties arise when repayment strategies are defined because software architects need to be aware of the consequences of these strategies over others decisions in the software architecture. This article proposes REBEL, a semi-automated model-driven approach that exploits natural language processing, machine learning and model checking techniques on heterogeneous project artifacts to build a model that allows to locate and visualize the impact produced by the consciously injected ATD and its repayment strategy on the other architectural decisions. The technique is illustrated with a data analytics project in Colombia where software architects are unaware of the consequences of the repayment strategies. This proposal seeks to support teams of architects to make explicit the current and future impact of the ATD injected as a result of decisions taken, focusing on the architectural level rather than code level."
160,2019,Software architecture social debt: managing the incommunicability factor,"Architectural technical debt is the additional project cost connected to technical issues nested in software architectures. Similarly, many practitioners have already experienced that there exists within software architectures a form of social debt, that is, the additional project cost connected to sociotechnical and organizational issues evident in or related to software architectures. This paper illustrates four recurrent antipatterns or community smells connected to such architectural social debt and outlines a means to measure the additional project cost connected to their underlying cause: decision incommunicability. Evaluating the results in multiple focus groups, this paper concludes that studying social debt and community smells at the architecture level may prove vital to rid software development communities of critical organizational flaws incurring considerable additional cost."
165,2019,Identifying scalability debt in open systems,"Architectural technical debt can be generated by changes in the business and the environment of an organization. In this paper, we emphasize the change in scalability requirements due to new regulations. Scalability is the ability of a system to handle an increased workload. For complex systems that are abruptly exposed via open interfaces and hence a greater workload, the scalability requirements may quickly increase, leading to technical debt. We term this scalability debt. This paper describes scalability triage, a light-weight, novel technique for identifying scalability threats as a form of technical debt. We illustrate this technique with an open banking case from a large software organization. Open banking is partly caused by the new European PSD2 regulative that enforce banks to open interfaces to unknown third-party actors. Banking systems are well-established, mature systems. However, with the advent of open banking and PSD2, the workload may quickly rocket. This leads to tougher scalability requirements and accumulated architectural debt, despite previously sound architectural decisions. Using scalability triage, such risks may be identified fast. It will then be possible to prevent this form of technical debt with timely reengineering."
168,2019,Measuring affective states from architectural technical debt,"Context: While the technological and financial aspects of technical debt have been extensively researched, the consequences on human aspects remain mostly uncharted. At the same time, recent psychoempirical software engineering research links the affects of software practitioners to organisational performance. Objective: To empirically investigate the causal relationship between architectural technical debt and the affects of software practitioners. Method: A mixed-methods approach with 40 software practitioners from 12 companies was used, combining repeated measurements laboratory experiments and semi-structured interviews. Result: Based on a set of 200 data points, the existence of tiny tangles negatively impacts the valence of software practitioners with more than 99 % certainty. No links were found between professional background and variations in affective state. Moreover, software practitioners receive positive affects from challenging software engineering tasks and negative affects from architectural technical debt and deadlines. Limitation: The subjects were industry professionals obtained through convenience sampling. Additionally, the treatments, albeit similar to industry code, were small and isolated examples that lacked the full spread and severity of technical debt encountered in practice. Conclusion: By combining our results with the existing literature on psychoempirical software engineering, strong arguments can be made in favour of the hypothesis that the effects of technical debt on industry professionals carry high technological and financial risks."
166,2019,Architectural technical debt in embedded systems,"Agile software development (ASD) has been employed effectively in the development of embedded systems, contributing to speeding up the delivery of value to the customers. However, some obstacles have been found, limiting the application of ASD to such a domain. This chapter focuses on one such challenges, the degradation of the system architecture over time, which is called, in literature, Architectural Technical Debt (ATD). Software engineering is an individual activity and the causes for ATD accumulation can be related to suboptimal decision taken by individual employees. New employees as well are more subjected to accumulating ATD due to the natural noncomplete understanding of the architecture and patterns. The chapter summarizes the causes, trends, consequences, and possible solutions related to the management of ATD. The results are all based on a strong collaboration with several software-intensive systems industries located in northern Europe and, consequently, relevant to all Industry 4.0 companies."
167,2019,Mitigating Technical and Architectural Debt with Sonargraph,"Sonargraph is a static analyzer with a focus on software architecture and metrics. The motivation to create Sonargraph came from the assumption that architectural debt (aka structural debt) is the most toxic form of technical debt. Repairing a broken architecture requires global and high-risk changes, while fixing other forms of technical debt mostly involves low-risk local changes. Therefore, the tool enables architects and developers to formally describe their architectural blueprint using a custom DSL (domain specific language). Once defined architectural rules can be checked and enforced in an automated way in all stages of the development process. This guarantees that a software system will never end up as the notorious ""big ball of mud"". Sonargraph currently supports Java, C#, C/C++ and Python and is used by hundreds of organizations worldwide."
175,2020,Managing security debt across PLC phases in a VSE context,"Nowadays, security and safety aspects are two of the major concerns for any software system development, especially while developing safety critical systems. This is especially relevant for very small entities because they have a limited amount of resources for dealing with all these aspects at the same time. In addition, these systems are highly regulated domains, and they involve a huge set of standards focused on safety and security-related issues. Therefore, these small entities are not only facing hurdles related to technical aspects but also from the so-called technical debt when overarching a critical development. This paper extends the assurance cases approach by integrating security aspects within the life cycle, and it proposes a framework for managing the associated security technical debt for very small entities. A tool chain is outlined, and the approach is illustrated with an industrial use case."
4,2020,Code Smells and Refactoring: A Tertiary Systematic Review of Challenges and Observations,"Refactoring and smells have been well researched by the software-engineering research community these past decades. Several secondary studies have been published on code smells, discussing their implications on software quality, their impact on maintenance and evolution, and existing tools for their detection. Other secondary studies addressed refactoring, discussing refactoring techniques, opportunities for refactoring, impact on quality, and tools support.

In this paper, we present a tertiary systematic literature review of previous surveys, secondary systematic literature reviews, and systematic mappings. We identify the main observations (what we know) and challenges (what we do not know) on code smells and refactoring. We perform this tertiary review using eight scientific databases, based on a set of five research questions, identifying 40 secondary studies between 1992 and 2018.

We organize the main observations and challenges about code smell and their refactoring into: smells definitions, most common code-smell detection approaches, code-smell detection tools, most common refactoring, and refactoring tools. We show that code smells and refactoring have a strong relationship with quality attributes, i.e., with understandability, maintainability, testability, complexity, functionality, and reusability. We argue that code smells and refactoring could be considered as the two faces of a same coin. Besides, we identify how refactoring affects quality attributes, more than code smells. We also discuss the implications of this work for practitioners, researchers, and instructors. We identify 13 open issues that could guide future research work.

Thus, we want to highlight the gap between code smells and refactoring in the current state of software-engineering research. We wish that this work could help the software-engineering research community in collaborating on future work on code smells and refactoring.

"
176,2020,Towards an Approach to Identify Obsolete Features based on Importance and Technical Debt,"Many of today's software systems are maintained over years or even decades. To ensure that software remains useful, new features have to be added or old features have to be adapted to respond to new or changed requirements. As time goes on, some of the features become obsolete, i.e., are not needed anymore. Typically, these features are not removed because of various reasons, e.g., because removing them might be considered too costly, the costs of keeping unused features is considered low, or because of the ""sunk cost fallacy"", i.e., that a feature is considered worth to keep because of the previously invested resources (time, money or effort) to build it. The consequences of keeping unused source code can impact maintainability, technical debt, performance, and extensibility of the system. This can lead to lower development productivity and to a reduced innovation ability, consequently reducing competitiveness on the market. This paper aims to present an approach to identify features based on their value and on costs for keeping or removing them."
170,2020,A preliminary analysis of self-adaptive systems according to different issues,"Self-adaptive systems dynamically change their structure and behavior in response to changes in their execution environment to ensure the quality of the services they provide. Self-adaptive systems are usually built of a managed part, which implements their functionality, and a managing part, which implements the self-adaptive mechanisms. Hence, the complexity of self-adaptive systems results also from the existence of the managing part and the interaction between the managed and the managing parts. The available evaluation approaches of self-adaptive systems focus on their performances, i.e., on the benefits (e.g., degree of autonomy, support for detecting anomalous behavior, adaptivity time, quality of response) achieved through the self-adaptive mechanisms of the managing part. In this paper, we evaluate the quality of the design of self-adaptive systems (including the managed and the managing parts) as it is done in traditional software engineering. We are interested in the internal software quality of self-adaptive systems, as the existence of the managing part and its interaction with the managed part leads to a tightly coupled system. We analyze the self-adaptive systems through the detection of different issues such as architectural and code smells and the detection of design patterns. The smells provide some hints on possible design and implementation problems, and help software engineers to improve the quality of the systems. While, design patterns are usually indicators of the application of good practices in the software development and allow to capture part of the design rationale. In this way, they can help software engineers to understand, reuse, and extend self-adaptive systems. In this paper, we have considered the detection of 3 architectural smells, 18 code smells, and 15 design patterns in 11 self-adaptive systems written in the Java programming language. The results indicate that the 3 architectural smells, 9 out of the 18 code smells, and the 15 design patterns have been detected in all the analyzed self-adaptive systems. We also discuss the possible reasons behind the presence of these quality issues, and provide our lessons learned."
171,2020,A modeling method for systematic architecture reconstruction of microservice-based software systems,"Microservice Architecture (MSA) is an approach to architecting service-based software systems, which aims for decreasing service coupling to enable independent service development and deployment. Consequently, the adoption of MSA is expected to particularly benefit the scalability, maintainability, and reliability of monolithic systems. However, MSA adoption also increases architectural complexity in service design, implementation, and operation. As a result, Software Architecture Reconstruction (SAR) of microservice architectures is aggravated. This paper presents a modeling method that systematizes SAR of microservice architectures with the goal to facilitate its execution. The method yields reconstruction models for certain architecture viewpoints in MSA to enable efficient architecture analysis. We validate the method’s applicability by means of a case study architecture and the assessment of its risk in technical debt using derived reconstruction models."
172,2020,Improving agility by managing shared libraries in microservices,"Using microservices is a way of supporting an agile architecture. However, if the microservices development is not properly managed, the teams’ development velocity may be affected, reducing agility and increasing architectural technical debt. This paper investigates how to manage the use of shared libraries in microservices to improve agility during development. We interviewed practitioners from four large international companies involved in microservices projects to identify problems when using shared libraries. Our results show that the participating companies had issues with shared libraries as follows: coupling among teams, delays on fixes due to overhead on libraries development teams, and need to maintain many versions of the libraries. Our results highlight that the use of shared libraries may hinder agility on microservices. Thus, their use should be restricted to situations where shared libraries cannot be replaced by a microservice and the costs of replicating the code on each service is very high."
173,2020,Characterizing Architectural Drifts of Adaptive Systems,"An adaptive system (AS) evaluates its own behavior and changes it when the evaluation indicates that the system is not accomplishing what it is intended to do, or when better functionality or performance is possible. MAPE-K is a reference model that prescribes the adaptation mechanism of ASs by means of high-level abstractions such as Monitors, Analyzers, Planners and Executors and the relationships among them. Since the abstractions and the relationships provided by MAPE-K are generic, other reference models were proposed focusing on providing lower level abstractions to support software engineers in a more suitable way. However, after the analysis of seven representative ASs, we realized the abstractions prescribed by the existing reference models are not properly implemented, thus leading to architectural drifts. Therefore, in this paper we characterized three of these drifts by describing them with a template and showing practical examples. The three architectural drifts of ASs are Scattered Reference Inputs, Mixed Executors and Effectors, and Obscure Alternatives. We expect that by identifying and characterizing these drifts, we can help software architects improve their design and, as a consequence, increase the reliability of this type of systems."
174,2020,Software Architecture Reconstruction via a Genetic Algorithm: Applying the Move Class Refactoring,"Modularity is one of the four key principles of software design and architecture. According to this principle, software should be organized into modules that are tightly linked internally (high cohesion), whereas at the same time as independent from other modules as possible (low coupling). However, in practice, this principle is violated due to poor architecting design decisions, lack of time, or coding shortcuts, leading to a phenomenon termed as architectural technical debt (ATD). To alleviate this problem (lack of architectural modularity), the most common solution is the application of a software refactoring, namely Move Class—i.e., moving classes (the core artifact in object-oriented systems) from one module to another. To identify Move Class refactoring opportunities, we employ a search-based optimization process, relying on optimization metrics, through which optimal moves are derived. Given the extensive search space required for applying a brute-force search strategy, in this paper, we propose the use of a genetic algorithm that re-arranges existing software classes into existing or new modules (software packages in Java, or folders in C++). To validate the usefulness of the proposed refactorings, we performed an industrial case study on three projects (from the Aviation, Healthcare, and Manufacturing application domains). The results of the study indicate that the proposed architecture reconstruction is able to improve modularity, improving both coupling and cohesion. The obtained results can be useful to practitioners through an open source tool; whereas at the same point, they open interesting future work directions."
187,2020,An empirical investigation on the relationship between design and architecture smells,"Context: Architecture of a software system represents the key design decisions and therefore its quality plays an important role to keep the software maintainable. Code smells are indicators of quality issues in a software system and are classified based on their granularity, scope, and impact. Despite a plethora of existing work on smells, a detailed exploration of architecture smells, their characteristics, and their relationships with smells in other granularities is missing. Objective: The paper aims to study architecture smells characteristics, investigate correlation, collocation, and causation relationships between architecture and design smells. Method: We implement smell detection support for seven architecture smells. We mine 3 073 open-source repositories containing more than 118 million lines of C# code and empirically investigate the relationships between seven architecture and 19 design smells. Results: We find that smell density does not depend on repository size. Cumulatively, architecture smells are highly correlated with design smells. Our collocation analysis finds that the majority of design and architecture smell pairs do not exhibit collocation. Finally, our causality analysis reveals that design smells cause architecture smells."
177,2020,Technical Debt Aware Estimations in Software Engineering: A Systematic Mapping Study,"Context: The Technical Debt metaphor has grown in popularity. More software is being created and has to be maintained. Agile methodologies, in particular Scrum, are widely used by development teams around the world. Estimation is an often practised step in sprint planning. The subject matter of this paper is the impact technical debt has on estimations. Objective: The goal of this research is to identify estimation problems and their solutions due to previously introduced technical debt in software projects. Method: The Systematic mapping study (SMS) method was applied in the research. Papers were selected from the popular digital databases (IEEE, ACM, Scopus, etc.) using defined search criteria. Afterwards, a snowballing procedure was performed and the final publication set was filtered using inclusion/exclusion criteria. Results: 42 studies were selected and evaluated. Five categories of problems and seven proposed solutions to the problems have been extracted from the papers. Problems include items related to business perspective (delivery pressure or lack of technical debt understanding by business decision-makers) and technical perspective (difficulties in forecasting architectural technical debt impact or limits of source code analysis). Solutions were categorized in: more sophisticated decision-making tools for business managers, better tools for estimation support and technical debt management tools on an architectural-level, portfolio approach to technical debt, code audit and technical debt reduction routine conducted every sprint. Conclusion: The results of this mapping study can help taking the appropriate approach in technical debt mitigation in organizations. However, the outcome of the conducted research shows that the problem of measuring technical debt impact on estimations has not yet been solved. We propose several directions for further investigation. In particular, we would focus on more sophisticated decision-making tools."
183,2020,A Semiautomatic Approach to Identify Architectural Technical Debt from Heterogeneous Artifacts,"Architectural Technical Debt (ATD) is a metaphor used to describe decisions taken by software architects to accomplish short-term goals but possibly negatively affecting the long-term health of the system. However, ATD doesn’t receive enough attention for the architect teams because it is hard to identify, to measure, to prioritize, and its value is related to long-term maintenance and evolution of a system. In this research, we propose a model-driven approach that focuses on building a binary classification model for ATD identification based on the information gathered from artifacts produced during architecture design. This model will allow software architects to support the managing of conscious and unconscious ATD in their software projects. This proposal focuses on TD at the architecture-level only without considering source code. The effectiveness of this proposal will be evaluated using case studies and expert interviews."
178,2020,Skuld: a self-learning tool for impact-driven technical debt management,"As the development progresses, software projects tend to accumulate Technical Debt and become harder to maintain. Multiple tools exist with the mission to help practitioners to better manage Technical Debt. Despite this progress, there is a lack of tools providing actionable and self-learned suggestions to practitioners aimed at mitigating the impact of Technical Debt in real projects. We aim to create a data-driven, lightweight, and self-learning tool positioning highly impactful refactoring proposals on a Jira backlog. Bearing this goal in mind, the first two authors have founded a startup, called Skuld.ai, with the vision of becoming the go-to software renovation company. In this tool paper, we present the software architecture and demonstrate the main functionalities of our tool. It has been showcased to practitioners, receiving positive feedback. Currently, its release to the market is underway thanks to an industry-research institute collaboration with Fraunhofer IESE to incorporate self-learning technical debt capabilities."
185,2020,A computational model of a natural language processing system for architectural technical debt management,"Technical debt is a concept applied to decisions taken to favor rapid production, at the expense of future capacities to evolve or improve the product or service. This concept is transversal to all sciences, especially in experimental physics and systems. However, technical debt is difficult to manage because there is a lack of time, expertise, or knowledge on how to perform it. This paper proposes a computational model of technical debt management in software architecture, based on observations made in software teams in their daily work. This computational model exploits natural language processing and model-testing techniques on software project artifacts to build a model that allows localizing and visualizing the impact produced by the technical debt and its payment strategies. This proposal aims to support teams of architects to explain the current and future impact of the debt injected as a result of decisions made."
184,2020,ATDx: Building an Architectural Technical Debt Index.,"Architectural technical debt (ATD) in software-intensive systems refers to the architecture design decisions which work as expedient in the short term, but later negatively impact system evolvability and maintainability. Over the years numerous approaches have been proposed to detect particular types of ATD at a refined level of granularity via source code analysis. Nevertheless, how to gain an encompassing overview of the ATD present in a software-intensive system is still an open question. In this study, we present a multi-step approach designed to build an ATD index (ATDx), which provides insights into a set of ATD dimensions building upon existing architectural rules by leveraging statistical analysis. The ATDx approach can be adopted by researchers and practitioners alike in order to gain a better understanding of the nature of the ATD present in software-intensive systems, and provides a systematic framework to implement concrete instances of ATDx according to specific project and organizational needs"
186,2020,Architectural technical debt: A grounded theory,"Architectural technical debt in a software-intensive system is driven by design decisions about its structure, frameworks, technologies, languages, etc. Unlike code-level technical debt, which can be readily detected by static analysers, and can often be refactored with minimal efforts, architectural debt is hard to detect, and its remediation is wide-ranging, daunting, and often avoided. The objective of this study is to develop a better understanding of how software development organisations conceptualize their architectural debt, and how they deal with it, if at all. We used a grounded theory method, eliciting qualitative data from software architects and senior technical staff from a wide range of software development organizations. The result of the study, i.e., the theory emerging from the collected data, constitutes an encompassing conceptual theory of architectural debt, identifying and relating concepts such as symptoms, causes, consequences, and management strategies. By grounding the findings in empirical data, the theory provides researchers and practitioners with evidence of which crucial factors of architectural technical debt are experienced in industrial contexts."
182,2020,Estimating Refactoring Efforts for Architecture Technical Debt,"Paying-off the Architectural Technical Debt by refactoring the flawed code is important to control the debt and to keep it as low as possible. Project Managers tend to delay paying off this debt because they face difficulties in comparing the cost of the refactoring against the benefits they gain. For these managers to decide whether to refactor or to postpone, they need to estimate the cost and the efforts required to conduct these refactoring ac- tivities as well as to decide which flaws have higher priority to be refactored among others.
Our research is based on a dataset used by other researchers in the technical debt field. It includes more than 18,000 refactoring operations performed on 33 apache java projects. To estimate the refactoring efforts done, we applied the COCOMO II:2000 model to calculate the refactoring cost in person-months units per release. Furthermore, we investigated the correla- tion between the refactoring efforts and two static code metrics of the refac- tored code, mainly, the LOC and the complexity. The research revealed a moderate correlation between the refactoring efforts and each one of the size of the project and code complexity. Finally, we applied the DesigniteJava tool and machine learning practices to verify our research results. From the analysis we found a significant correlation between the ranking of the architecture smells and the ranking of refactoring efforts for each package. Using machine learning practices, we took the architecture smells level and the code metrics of each release as an input to predict the levels of the refac- toring effort of the next release. We calculated the results using our model and found that we can predict the higher refactoring cost levels with 93% accuracy."
181,2020,Methods for Identifying Architectural Debt: A Systematic Mapping Study,"Technical debt in general refers to suboptimal decisions the practitioners make during software development that achieve short-term goals at the expense of long-term quality concerns. Architecture technical debt is a subset of technical debt, when software practitioners make wrong or sub-optimal decisions related to the architecture of the software. Identifying such architecture technical debt plays a crucial role in software quality. In the last decade, there were several methods proposed to identify architecture debts in the literature.In this study, we conduct a systematic literature review of methods that identify architecture technical debt by inspecting 28 primary studies published from 2011 to 2020. Based on the outcomes of our review: (1) design rule space and traceability graphs are the dominant techniques; (2) despite the increase of automated techniques in identifying architecture debt, pure manual methods using expert opinion is still popular; (3) majority of the approaches use code/version history to mine archictural technical debt; (4) the field is getting increasingly more attraction in the last five years."
180,2020,Long-Term Evaluation of Technical Debt in Open-Source Software,"Background: A consistent body of research and practice have identified that technical debt provides valuable and actionable insight into the design and implementation deficiencies of complex software systems. Existing software tools enable characterizing and measuring the amount of technical debt at selective granularity levels; by providing a computational model, they enable stakeholders to measure and ultimately control this phenomenon. Aims: In this paper we aim to study the evolution and characteristics of technical debt in open-source software. For this, we carry out a longitudinal study that covers the entire development history of several complex applications. The goal is to improve our understanding of how the amount and composition of technical debt changes in evolving software. We also study how new technical debt is introduced in software, as well as identify how developers handle its accumulation over the long term. Method: We carried out our evaluation using three complex, open-source Java applications. All 110 released versions, covering more than 10 years of development history for each application were analyzed using SonarQube. We studied how the amount, composition and history of technical debt changed during development, compared our results across the studied applications and present our most important findings. Results: For each application, we identified key versions during which large amounts of technical debt were added, removed or both. This had significantly more impact when compared to the lines of code or class count increases that generally occurred during development. However, within each version, we found high correlation between file lines of code and technical debt. We observed that the Pareto principle was satisfied for the studied applications, as 20% of issue types generated around 80% of total technical debt. Interestingly, there was a large degree of overlap between the issues that generated most of the debt across the studied applications. Conclusions: Early application versions showed greater fluctuation in the amount of existing technical debt. We found application size to be an unreliable predictor for the quantity of technical debt. Most debt was introduced in applications as part of milestone releases that expanded their feature set; likewise, we identified releases where extensive refactoring significantly reduced the level of debt. We also discovered that technical debt issues persist for a long time in source code, and their removal did not appear to be prioritized according to type or severity."
179,2020,How do software architects perceive technical debt in Colombian industry? An analysis of technical debt causes,"Technical debt is a metaphor used to describe technical decisions that can give the company a benefit in the short term but possibly hurting the overall quality of the software in the long term. Architectural decisions are considered one of the most common sources of technical debt, therefore, it becomes relevant to understand what causes lead to technical debt from the point of view of software architects. To accomplish this task, we used a survey research method to collect and analyze a corpus of 28 software architects from Colombia, as a part of the InsighTD project. Results showed that inappropriate planning is the most cited technical debt cause by software architects. However, results differ when comparison against engineers and manager are performed. Innacurate time estimate and producing more without quality were the most selected causes of technical debt according to engineers and managers. To improve this comparison, the rank-biased overlapping technique was used. As more elements were compared, more similar were these lists of causes among all three roles."
199,2021,Identification and Measurement of Technical Debt Requirements in Software Development: a Systematic Literature Review,"Context: Technical Debt requirements are related to the distance between the ideal value of the specification and the system's actual implementation, which are consequences of strategic decisions for immediate gains, or unintended changes in context. To ensure the evolution of the software, it is necessary to keep it managed. Identification and measurement are the first two stages of the management process; however, they are little explored in academic research in requirements engineering. Objective: We aimed at investigating which evidence helps to strengthen the process of TD requirements management, including identification and measurement. Method: We conducted a Systematic Literature Review through manual and automatic searches considering 7499 studies from 2010 to 2020, and including 61 primary studies. Results: We identified some causes related to Technical Debt requirements, existing strategies to help in the identification and measurement, and metrics to support the measurement stage. Conclusion: Studies on TD requirements are still preliminary, especially on management tools. Yet, not enough attention is given to interpersonal issues, which are difficulties encountered when performing such activities, and therefore also require research. Finally, the provision of metrics to help measure TD is part of this work's contribution, providing insights into the application in the requirements context."
198,2021,Detecting the Locations and Predicting the Costs of Compound Architectural Debts,"Architectural Technical Debt (ATD) refers to sub-optimal architectural design in a software system that incurs high maintenance ``interest"" over time. Previous research revealed that ATD has significant negative impact on daily development. This paper contributes an approach to enable an architect to precisely locate ATDs, as well as capture the trajectory of maintenance cost on each debt, based on which, predict the cost of the debt in a future release. The ATDs are expressed in four typical patterns, which entail the core of each debt. Furthermore, we aggregate compound ATDs to capture the complicated relationship among multiple ATD instances, which should be examined together for effective refactoring solutions. We evaluate our approach on 18 real-world projects. We identified ATDs that persistently incur significant (up to 95% of) maintenance costs in most projects. The maintenance costs on the majority of debts fit into a linear regression model---indicating stable ``interest"" rate. In five projects, 12.1% to 27.6% of debts fit into an exponential model, indicating increasing ``interest"" rate, which deserve higher priority from architects. The regression models can accurately predict the costs of the majority of (82% to 100%) debts in the next release of a system. By aggregating related ATDs, architects can focus on a small number of cost-effective compound debts, which contain a relatively small number of source files, but account for a large portion of maintenance costs in their projects. With these capabilities, our approach can help architects make informed decisions regarding whether, where, and how to refactor for eliminating ATDs in their systems."
197,2021,Asset management taxonomy: A roadmap,"Context: Developing software-intensive products or services involves utilising many artefacts that are either part of the offering or part of enabling their development. These artefacts, if valuable and used more than once by the development organisation, can be seen as assets such as test cases, code, requirements, and documentation. As such, assets are often reused, updated, and become a base or even necessity for product development and evolution over time, constituting an investment. Assets are not well understood beyond code-based ones in the area of technical debt. Thus most asset types are often overlooked, and their state, which is subject to degradation over time, has not been much studied. Method: To address the problem, we conducted industrial focus groups with five companies and a literature review. The results were analysed qualitatively and summarised in a taxonomy. Results: We created a structured, extendable taxonomy of assets. The taxonomy contains 57 assets. Conclusions: The taxonomy serves as foundations for defining and identifying assets as a concept. It provides the foundation for studies into asset degradation and subsequent asset management. The taxonomy also includes code-based assets and thus can be helpful in further research into investigating degradation and debt concepts."
196,2021,An Evolutionary Analysis of Software-Architecture Smells,"If software quality assurance is postponed or even abandoned for a software system, maintenance and evolution become harder or even impossible. One widely known symptom for the degradation of system quality are Architecture Smells (ASs), which violate fundamental principles of software design. In this paper, we present a study on the evolution of ASs as well as on how and when they foster system degradation. Thus, we provide valuable insights regarding what ASs are meaningful to assure system quality. To this end, we analyzed the evolution of three types of ASs in 14 open-source systems with a total of 485 versions. We adapted indicators used in previous studies to assess the severity of ASs (e.g., growth, lifetime), and relate ASs to technical debt as another established indicator. Our results indicate that 1) ASs remain mostly stable compared to the code size of a system, 2) certain types of ASs, such as cyclic dependencies, have a greater impact on system degradation, and 3) certain properties determine how much an AS contributes to software degradation. These findings are valuable for practitioners to identify and tackle system degeneration, as well as for researchers to scope new research on managing ASs and technical debt."
195,2021,A systematic mapping study on architectural smells detection,"The recognition of the need for high-quality software architecture is evident from the increasing trend in investigating architectural smells. Detection of architectural smells is paramount because they can seep through to design and implementation stages if left unidentified. Many architectural smells detection techniques and tools are proposed in the literature. The diversity in the detection techniques and tools suggests the need for their collective analysis to identify interesting aspects for practice and open research areas. To fulfill this, in this paper, we unify the knowledge about the detection of architectural smells through a systematic mapping study. We report on the existing detection techniques and tools for architectural smells to identify their limitations. We find there has been limited investigation of some architectural smells (e.g., micro-service smells); many architectural smells are not detected by tools yet; and there are limited empirical validations of techniques and tools. Based on our findings, we suggest several open research problems, including the need to (1) investigate undetected architectural smells (e.g., Java package smells), (2) improve the coverage of architectural smell detection across architecture styles (e.g., service-oriented and cloud), and (3) perform empirical validations of techniques and tools in industry across different languages and project domains."
216,2021,Business-driven technical debt prioritization: An industrial case study,"Incorporating the business perspective into prioritizing technical debt is essential to contribute to decision making in industry. In this paper, we evolve and evaluate a business-driven approach for technical debt prioritization. The approach was evaluated during a five-months industrial case study with business and technical stakeholders' active participation. The results show that the approach contributed to aligning business criteria between the business and technical stakeholders. We also observed a downward trend in the amount of technical debt that affects high-value business assets. Moreover, we identified eight business factors that affect the decision making related to the prioritization of technical debt. The study results suggest that the proposed business-driven technical debt prioritization approach can help teams to focus their efforts on paying off the business' most relevant debt."
190,2021,Qualities of Quality: A Tertiary Review of Software Quality Measurement Research,"This paper presents a tertiary review of software quality measurement research. To conduct this review, we examined an initial dataset of 7,811 articles and found 75 relevant and high-quality secondary analyses of software quality research. Synthesizing this body of work, we offer an overview of perspectives, measurement approaches, and trends. We identify five distinct perspectives that conceptualize quality as heuristic, as maintainability, as a holistic concept, as structural features of software, and as dependability. We also identify three key challenges. First, we find widespread evidence of validity questions with common measures. Second, we observe the application of machine learning methods without adequate evaluation. Third, we observe the use of aging datasets. Finally, from these observations, we sketch a path toward a theoretical framework that will allow software engineering researchers to systematically confront these weaknesses while remaining grounded in the experiences of developers and the real world in which code is ultimately deployed."
192,2021,Exploring the relation between co-changes and architectural smells,"The interplay between Maintainability and Reliability can be particularly complex and different kinds of trade-offs may arise when developers try to optimise for either one of these two qualities. To further understand how Maintainability and Reliability influence each other, we perform an empirical study using architectural smells and source code file co-changes as proxies for these two qualities, respectively. The study is designed using an exploratory multiple-case case study following well-know guidelines and using fourteen open source Java projects. Three different research questions are identified and investigated through statistical analysis. Co-changes are detected by using both a state-of-the-art algorithm and a novel approach. The three architectural smells selected are among the most important from the literature and are detected using open source tools. The results show that 50% of co-changes eventually end up taking part in an architectural smell. Moreover, statistical tests indicate that in 50% of the projects, files and packages taking part in smells are more likely to co-change than non-smelly files. Finally, co-changes were also found to appear before smells 90% of the times a smell and a co-change appear in the same file pair. Our findings show that Reliability is indirectly affected by low levels of Maintainability even at the architectural level. This is because low-quality components require more frequent changes by the developers, increasing chances to eventually introduce faults."
191,2021,Legacy Digital Transformation: TCO and ROI Analysis,"Legacy Digital Transformation is modernizing or migrating systems from non-digital or older digital technology to newer digital technologies. Digitalization is essential for information reading, processing, transforming, and storing. Social media, Cloud, and analytics are the major technologies in today's digital world. Digitalization (business process) and Digital Transformation (the effect) are the core elements of newer global policies and processes. Recent COVID pandemic situation, Organizations are willing to digitalize their environment without losing business. Digital technologies help to improve their capabilities to transform processes that intern promote new business models. Applications cannot remain static and should modernize to meet the evolving business and technology needs. Business needs time to market, Agility, and reduce technical debt. Technology needs consist of APIs, better Security, Portability, Scalability, Cloud support, Deployment, Automation, and Integration. This paper elaborates different transformation/modernization approaches for Legacy systems written in very long or End of Life (EOL) systems to newer digital technologies to serve the business needs. EOL impacts application production, supportability, compliance, and security. Organizations spend money and resources on Digital Transformation for considering Investment versus Return on Investment, Agility of the System, and improved business processes. Migration and Modernization are critical for any Legacy Digital Transformation. Management takes decisions to proceed with Digital Transformation for considering Total Cost Ownership (TCO) and Return on Investment (ROI) of the program. The paper also includes a TCO-ROI calculator for Transformation from Legacy / Monolithic to new architectures like Microservices."
200,2021,The Impact of Human Factors on Software Sustainability,"Software engineering is a constantly evolving subject area that faces new challenges every day as it tries to automate newer business processes. One of the key challenges to the success of a software solution is attaining sustainability. The inability of numerous software to sustain for the desired time length is caused by limited consideration given to sustainability during the stages of software development. This chapter presents a detailed and inclusive study covering human factor-related challenges of and approaches to software sustainability. Sustainability can be achieved by conducting specific activities at the human, environmental, and economic level. Human factors include critical social activities such as leadership and communication. This chapter groups the existing research efforts based on the above aspects. Next, how those aspects affect software sustainability is studied via a survey of software practitioners. Based on the findings, it was observed that human sustainability aspects are important, and that taking one into consideration and ignoring the other factors will threaten the sustainability of software products. Despite the noteworthy advantages of making a software sustainable, the research community has presented only a limited number of approaches that contribute to improving the human factors to achieve sustainability. To the best of our knowledge, these representations require further research. In this regard, an organized, structured, and detailed study is required on existing human factor-related sustainability approaches which will serve as a one-stop-service for researchers and software engineers who are willing to learn about these."
189,2021,Importance of software architectures in mobile projects,"Mobile projects often exhibit architectural issues. In this paper, we survey three different types of persons (instructors, students, and developers) to find out how often do those who write code struggle with architectural issues and how are those issues impacting their work. Our focus was on mobile projects, but to have a comprehensive overview, we have also questioned students - who might become mobile developers, to see if they understand the importance of architecture in their projects. We were also interested in instructors and their experience with the students on whether or not they lack architectural knowledge. Our research has found that all the questioned developers struggle with architectural issues in their projects, over 60% of the students had to re-write a project due to architectural issues, and over 94% of the questioned instructors stated that students have architectural issues in the projects they develop. The vast majority of the participants to the survey (100% of instructors, 100% of students, and 90% of developers) agreed that a tool that could validate the software architecture would help them.
"
188,2021,A method for monitoring the coupling evolution of microservice-based architectures,"The microservice architecture is claimed to satisfy ongoing software development demands, such as resilience, flexibility, and velocity. However, developing applications based on microservices also brings some drawbacks, such as the increased software operational complexity. Recent studies have also pointed out the lack of methods to prevent problems related to the maintainability of these solutions. Disregarding established design principles during the software evolution may lead to the so-called architectural erosion, which can end up in a condition of unfeasible maintenance. As microservices can be considered a new architecture style, there are few initiatives to monitoring the evolution of software microservice-based architectures. In this paper, we introduce the SYMBIOTE method for monitoring the coupling evolution of microservice-based systems. More specifically, this method collects coupling metrics during runtime (staging or production environments) and monitors them throughout software evolution. The longitudinal analysis of the collected measures allows detecting an upward trend in coupling metrics that could represent signs of architectural degradation. To develop the proposed method, we performed an experimental analysis of the coupling metrics behavior using artificially generated data. The results of these experiment revealed the metrics behavior in different scenarios, providing insights to develop the analysis method for the identification of architectural degradation. We evaluated the SYMBIOTE method in a real-case open source project called Spinnaker. The results obtained in this evaluation show the relationship between architectural changes and upward trends in coupling metrics for most of the analyzed release intervals. Therefore, the first version of SYMBIOTE has shown potential to detect signs of architectural degradation during the evolution of microservice-based architectures."
193,2021,Understanding architecture erosion: The practitioners’ perceptive,"As software systems evolve, their architecture is meant to adapt accordingly by following the changes in requirements, the environment, and the implementation. However, in practice, the evolving system often deviates from the architecture, causing severe consequences to system maintenance and evolution. This phenomenon of architecture erosion has been studied extensively in research, but not yet been examined from the point of view of developers. In this exploratory study, we look into how developers perceive the notion of architecture erosion, its causes and consequences, as well as tools and practices to identify and control architecture erosion. To this end, we searched through several popular online developer communities for collecting data of discussions related to architecture erosion. Besides, we identified developers involved in these discussions and conducted a survey with 10 participants and held interviews with 4 participants. Our findings show that: (1) developers either focus on the structural manifestation of architecture erosion or on its effect on run-time qualities, maintenance and evolution; (2) alongside technical factors, architecture erosion is caused to a large extent by non-technical factors; (3) despite the lack of dedicated tools for detecting architecture erosion, developers usually identify erosion through a number of symptoms; and (4) there are effective measures that can help to alleviate the impact of architecture erosion."
194,2021,A study on correlations between architectural smells and design patterns,"Design patterns are recommended solutions for typical software design problems, with an extensively studied and documented impact on various quality factors. Flaws in design at a higher levels of abstraction are manifested in architectural smells. Some of those smells, similarly to code smells, can reduce the expected advantages of design patterns or even prevent their proper implementation. In this paper we study if and how design patterns and architectural smells are related, and how this knowledge could be exploited in practice. We present an empirical study with an analysis of 16 design patterns and 3 architectural smells in 60 open source Java systems. We analyze their diffuseness and correlation, and we extract association rules that describe their presence and dependencies. We demonstrate that there exist relationships between architectural smells and design patterns, both at the class and package levels. Some smells appear falsely positive, as they result from conscious decisions made by programmers, while the application of some patterns can be a cause of certain smells. Our results provide evidence that design patterns and architectural smells are related and affect each other. With knowledge about the relationships, programmers can avoid the side effects of applying some design patterns."
214,2021,How do technical debt payment practices relate to the effects of the presence of debt items in software projects?,"Context: Knowing the effects of technical debt (TD) can support software development teams in the prioritization of TD items to pay off. However, little is known about the relations between the effects of TD and TD payment practices. Having this knowledge can provide valuable information for decision making about which payment practice can be applied given the presence of specific effects of TD. Aims: To investigate, from the point of view of software practitioners, (i) which TD payment practices have been used when certain effects of the presence of debt are felt in software projects and (ii) the reasons for not paying debt items despite the effects they are causing to the project. Method: We analyze quantitatively and qualitatively data collected from a survey with 432 practitioners across four countries. Results: Among the identified relations, the practice ""code refactoring"" is commonly used to pay debt items off when the effects ""delivery delay"" and ""rework"" are felt in software projects. On the other hand, when practitioners face the TD effects ""low external quality"" and ""delivery delay"", ,they commonly justify the non- payment of the debt items indicating the need of ""focusing on short term goals"". Conclusion: We organize the relationship between TD effects, and payment practices and reasons for not eliminating debt items. All this information is structured in an alluvial diagram, which can facilitate the visualization of the identified relations."
202,2021,On the practitioners’ understanding of coupling smells—A grey literature based Grounded-Theory study,"Context:
Code and design smells, such as the coupling smells examined in this article, are widely studied. Existing empirical studies reveal gaps between the scientific theory and practice, not yet explained by the scientific literature. Only basic coupling smell detection approaches and metrics seem to have been transferred to practice so far.

Objective:
This article aims to study the current practitioner’s understanding of coupling smells.

Method:
Based on grey literature sources containing practitioner views on coupling smells, we performed a Grounded Theory (GT) study. We used UML-based modeling to precisely encode our findings and performed a rigorous analysis of our codes and models.

Results:
Our results are defining factors of coupling smells, as well as smell impacts, trade-offs, relationships to other smells, relationships to practices and patterns, and fix options as perceived by practitioners. We further identified gaps in the understanding of coupling smells between science and practice, and derived opportunities and challenges for future scientific work.

Conclusions:
Five lessons are presented as opportunities and challenges for future research. Our results can help scientists to get a better understanding of practitioner concerns, and practitioners to get an overview of the current perception of other practitioners on coupling smells."
201,2021,On Microservice Analysis and Architecture Evolution: A Systematic Mapping Study,"Microservice architecture has become the leading design for cloud-native systems. The highly decentralized approach to software development consists of relatively independent services, which provides benefits such as faster deployment cycles, better scalability, and good separation of concerns among services. With this new architecture, one can naturally expect a broad range of advancements and simplifications over legacy systems. However, microservice system design remains challenging, as it is still difficult for engineers to understand the system module boundaries. Thus, understanding and explaining the microservice systems might not be as easy as initially thought. This study aims to classify recently published approaches and techniques to analyze microservice systems. It also looks at the evolutionary perspective of such systems and their analysis. Furthermore, the identified approaches target various challenges and goals, which this study analyzed. Thus, it provides the reader with a roadmap to the discipline, tools, techniques, and open challenges for future work. It provides a guide towards choices when aiming for analyzing cloud-native systems. The results indicate five analytical approaches commonly used in the literature, possibly in combination, towards problems classified into seven categories"
215,2021,Characterizing technical debt and antipatterns in ai-based systems: A systematic mapping study,"Background: With the rising popularity of Artificial Intelligence (AI), there is a growing need to build large and complex AI-based systems in a cost-effective and manageable way. Like with traditional software, Technical Debt (TD) will emerge naturally over time in these systems, therefore leading to challenges and risks if not managed appropriately. The influence of data science and the stochastic nature of AI-based systems may also lead to new types of TD or antipatterns, which are not yet fully understood by researchers and practitioners. Objective: The goal of our study is to provide a clear overview and characterization of the types of TD (both established and new ones) that appear in AI-based systems, as well as the antipatterns and related solutions that have been proposed. Method: Following the process of a systematic mapping study, 21 primary studies are identified and analyzed. Results: Our results show that (i) established TD types, variations of them, and four new TD types (data, model, configuration, and ethics debt) are present in AI-based systems, (ii) 72 antipatterns are discussed in the literature, the majority related to data and model deficiencies, and (iii) 46 solutions have been proposed, either to address specific TD types, antipatterns, or TD in general. Conclusions: Our results can support AI professionals with reasoning about and communicating aspects of TD present in their systems. Additionally, they can serve as a foundation for future research to further our understanding of TD in AI-based systems."
213,2021,Systematically reviewing the layered architectural pattern principles and their use to reconstruct software architectures,"Architectural reconstruction is a reverse engineering activity aiming at recovering the missing decisions on a system. It can help identify the components, within a legacy software application, according to the application's architectural pattern. It is useful to identify architectural technical debt. We are interested in identifying layers within a layered application since the layered pattern is one of the most used patterns to structure large systems. Earlier component reconstruction work focusing on that pattern relied on generic component identification criteria, such as cohesion and coupling. Recent work has identified architectural-pattern specific criteria to identify components within that pattern. However, the architectural-pattern specific criteria that the layered pattern embodies are loosely defined. In this paper, we present a first systematic literature review (SLR) of the literature aiming at inventorying such criteria for layers within legacy applications and grouping them under four principles that embody the fundamental design principles under-lying the architectural pattern. We identify six such criteria in the form of design rules. We also perform a second systematic literature review to synthesize the literature on software architecture reconstruction in the light of these criteria. We report those principles, the rules they encompass, their representation, and their usage in software architecture reconstruction."
212,2021,Worst smells and their worst reasons,"Code bad smells are symptoms of poor design and implementation. There are several well-known smell types, such as large classes (aka God classes), code clones, etc. and they have been shown to lead to technical debt and hence to decrease code maintainability. Quality gates are a recent technology that prevents the automatic acceptance of push requests of code commits that have been identified as containing certain smells. However, it is a challenging activity to decide which smells should be included in the quality gate, as developers may choose to optimize short term benefits like time to market over long term benefits like maintainability. But some smells appear to provide no benefit to developers whatsoever and hence such smells should always be avoided. The aims of this paper are: 1) to identify ""worst smells"", i.e., bad smells that never have a good reason to exist, 2) to determine the frequency, change-proneness, and severity associated with worst smells, and 3) to identify the ""worst reasons"", i.e., the reasons for introducing these worst smells in the first place. To achieve these aims we ran a survey with 71 developers. We learned that 80 out of 314 catalogued code smells are ""worst""; that is, developers agreed that these 80 smells should never exist in any code base. We then checked the frequency and change-proneness of these worst smells on 27 large Apache open- source projects. Our results show insignificant differences, in both frequency and change proneness, between worst and non-worst smells. That is to say, these smells are just as damaging as other smells, but there is never any justifiable reason to introduce them. Finally, in follow-up phone interviews with five developers we confirmed that these smells are indeed worst, and the interviewees proposed seven reasons for why they may be introduced in the first place. By explicitly identifying these seven reasons, project stakeholders can, through quality gates or reviews, ensure that such smells are"
210,2021,Agile elicitation of scalability requirements for open systems: A case study,"Eliciting scalability requirements during agile software development is complicated and poorly described in previous research. This article presents a lightweight artifact for eliciting scalability requirements during agile software development: the ScrumScale model. The ScrumScale model is a simple spreadsheet. The scalability concepts underlying the ScrumScale model are clarified in this design science research, which also utilizes coordination theory. This paper describes the open banking case study, in which a legacy banking system becomes open. This challenges the scalability of this legacy system. The first step in understanding this challenge is to elicit the new scalability requirements. In the open banking case study, key stakeholders from TietoEVRY spent 55 h eliciting the scalability requirements of TietoEVRY’s open banking project. According to TietoEVRY, the ScrumScale model provided a systematic way of producing scalability requirements. For TietoEVRY, the scalability concepts behind the ScrumScale model also offered significant advantages in dialogs with other stakeholders."
209,2021,Architecture Style Selection using Statistics of Quality Attributes to Reduce Production Costs,
211,2021,Architecture violations detection and visualization in the continuous integration pipeline,"New code in projects can introduce violations that deviate the code implementation from the intended architecture. This process is known as architecture erosion. In this article, we propose an approach for recovering the implemented architecture, and detecting violations when comparing it with the intended architecture. Given a code repository, the continuous integration pipeline calls the solution to detect the incidences of architecture violations as well as some quality and social metrics. This data is presented in metric-centered views that help development teams to manage architecture erosion. Our approach is based on model-driven engineering techniques since models serve to represent the code, and a model-based pattern language helps us to automate the search for violation occurrences and execute corresponding actions (e.g., creation/assignment of issues). We confirm the approach benefits in a real project implemented by a software developing company, in a sample project available on the internet, and in a software development course, including 20 projects, where every single project decreases its architecture violations density through time."
207,2021,One Step Further: Investigating Problematic Files of Architecture Anti-patterns,"Architecture anti-patterns violate design principles and negatively impact software internal quality. Both academia and industry have designed methods and tools to detect anti-patterns. However, these tools tend to report a large number of defects, hindering developers from prioritizing true debts. In this work, we take one step further to explore the most problematic files (we define them as root files) in the architecture anti-patterns, which are potential causes leading to the difficulty of software maintenance. Using 45 Python projects as subjects, we investigate root files' maintainability, evolution (i.e., birth, living, and death), and their interactions in different architecture anti-patterns. Our results reveal that, compared with other files in anti-patterns, these root files take only a small proportion but incur heavy maintenance costs. Our study of their evolution and interactions can help developers identify potential causes of anti-patterns. We believe our findings will benefit the practice of design problem fixing."
206,2021,SEMANTIC REVIEW ON SOFTWARE ARCHITECTURES FOR WEB-BASED APPLICATIONS,"Different Software Architecture evolves for the last two to three decades. Organizations depend on Architects to provide the Solutions given business requirements. The Architect job is to provide the Solutions to suit the Business needs and follows the industry standards. Architects have to understand the requirement clearly and provide the Solution. Some of the Solutions that exist in the IT industry for the last two to three decades are N-Tier Architecture, Single Page Architecture, Microservices, and Serverless Architecture. Based on the requirement, any one of the Architecture would propose taking considerations of functional and non-functional requirements. Last three years, most of the projects executed in Single Page along with Microservices Architectures used. This paper elaborates on the different Architectures and their advantages and disadvantages. Prepared questioners and send them to fifty Architects, responded of twenty-five (50% response). Survey collected the information on how the Organizations adopting different Architectures in their project needs. Participants are working from different geographic locations, Organizations, and domains. A survey result clearly shows that 50% growth towards the Microservices based architectures for their significant advantage and benefit."
205,2021,Grey literature in software engineering: A critical review,"Context:
Grey Literature (GL) recently has grown in Software Engineering (SE) research since the increased use of online communication channels by software engineers. However, there is still a limited understanding of how SE research is taking advantage of GL.

Objective:
This research aimed to understand how SE researchers use GL in their secondary studies.

Methods:
We conducted a tertiary study of studies published between 2011 and 2018 in high-quality software engineering conferences and journals. We then applied qualitative and quantitative analysis to investigate 446 potential studies.

Results:
From the 446 selected studies, 126 studies cited GL but only 95 of those used GL to answer a specific research question representing almost 21% of all the 446 secondary studies. Interestingly, we identified that few studies employed specific search mechanisms and used additional criteria for assessing GL. Moreover, by the time we conducted this research, 49% of the GL URLs are not working anymore. Based on our findings, we discuss some challenges in using GL and potential mitigation plans.

Conclusion:
In this paper, we summarized the last 10 years of software engineering research that uses GL, showing that GL has been essential for bringing practical new perspectives that are scarce in traditional literature. By drawing the current landscape of use, we also raise some awareness of related challenges (and strategies to deal with them).

"
204,2021,Software product quality metrics: A systematic mapping study,"In the current competitive world, producing quality products has become a prominent factor to succeed in business. In this respect, defining and following the software product quality metrics (SPQM) to detect the current quality situation and continuous improvement of systems have gained tremendous importance. Therefore, it is necessary to review the present studies in this area to allow for the analysis of the situation at hand, as well as to enable us to make predictions regarding the future research areas. The present research aims to analyze the active research areas and trends on this topic appearing in the literature during the last decade. A Systematic Mapping (SM) study was carried out on 70 articles and conference papers published between 2009 and 2019 on SPQM as indicated in their titles and abstract. The result is presented through graphics, explanations, and the mind mapping method. The outputs include the trend map between the years 2009 and 2019, knowledge about this area and measurement tools, issues determined to be open to development in this area, and conformity between conference papers, articles and internationally valid quality models. This study may serve as a foundation for future studies that aim to contribute to the development in this crucial field. Future SM studies might focus on this subject for measuring the quality of network performance and new technologies such as Artificial Intelligence (AI), Internet of things (IoT), Cloud of Things (CoT), Machine Learning, and Robotics."
203,2021,The Existence and Co-Modifications of Code Clones within or across Microservices,"In recent years, microservice architecture has been widely applied in software design. In addition, more and more monolithic software systems have been migrated into a microservice architecture. The core idea is to decompose the concerns of software projects into small and loosely-coupled services. Each service is supposed to be developed and even managed independently, which in turn improving the efficiency of development and maintenance. Code clone is common during software implementations, and many prior studies have revealed that code clones could cause maintenance difficulties. However, there is little work exploring the impacts of code clones on microservice projects. To bridge this gap, we focus on exploring the existence and co-modifications of within-service and cross-service code clones. With our evaluation of eight microservice projects, we have presented that there still exist code clones within services or across services. In addition, both within-service and cross-service code clones have been involved in co-modifications, meaning that these clones have caused maintenance difficulties. Finally, we have explored the characteristics of co-modifications in terms of changed LOC for both within-service and cross-service code clones."
208,2021,Identifying Domain-Based Cyclic Dependencies in Microservice APIs Using Source Code Detectors,"Isolation, autonomy, and loose coupling are critical success factors of microservice architectures. Unfortunately, systems tend to become strongly coupled over time, sometimes even exhibiting cyclic communication chains, making the individual deployment of services challenging. Such chains are highly problematic when strongly coupled communication e.g. based on synchronous invocations is used, but also create complexity and maintenance issues in more loosely coupled asynchronous or event-based communication. Here, cycles only manifest on a conceptual or domain level, making them hard to track for algorithms that rely solely on static analysis. Accordingly, previous attempts to detect cycles either focused on synchronous communication or had to collect additional runtime data, which can be costly and time-consuming. We suggest a novel approach for identifying and evaluating domain-based cyclic dependencies in microservice systems based on modular, reusable source code detectors. Based on the architecture model reconstructed by the detectors, we derived a set of architectural metrics for detecting and classifying domain-based cyclical dependencies. By conducting two case studies on open-source microservice architectures, we validated the feasibility and applicability of our approach."
0,2021,Identification of Technical Debt in Code using Software Metrics,"The metaphor Technical Debt describes the consequences of taking shortcuts
in the software development process for short-term benefit, at the expense of
higher maintenance in the future. Every large software system contains Technical
Debt in some way or another, the di cult question is to know when, where, and
how to repay the debt.
To answer this we conducted three main steps. A literature study on how
to identify, measure, and manage Technical Debt (i), interviews (ii), and finding
key software metrics based on the Goal-Question-Metric paradigm to build a
Technical Debt Model with a visualisation dashboard (iii). This was used for
a case study at an organisation where files from two projects were analysed and
the model was evaluated by comparing the results with opinions from developers
who created the system.
The final model used 8 metrics as input and had a total success rate of 80%
when comparing the model’s ranking with mutual opinion of the developers.
The dashboard was seen to be a useful tool for discussion and a quick way
to identify areas in the code with Technical Debt. It was also discovered that
measuring Technical Debt with only software metrics is a hard to impossible task,
and many sources of information must be used in conjunction. To circumvent
this, an implementation model for the organisation using several information
channels together with the dashboard was created."
232,2021,Technical Debt Impacting Lead-Times: An Exploratory Study,"Background: Technical Debt is a consolidated notion in software engineering research and practice. However, the estimation of its impact (interest of the debt) is still imprecise and requires heavy empirical and experimental inquiry. Objective: We aim at developing a data-driven approach to calculate the interest of Technical Debt in terms of delays in resolving affected tasks.Method: We conducted a case study to estimate the Technical Debt interest by analyzing its association with the lead time variation of resolving related Jira issues.Results: Data-driven approaches could significantly change the Technical Debt estimation and improve the removing Technical Debt prioritization. Our case study shows that the presence of Code Technical Debt did not affect the lead time for resolving the issues.Conclusion: Future works include the further refinement of this approach and its application to a larger data-set and on different type of issues."
233,2021,Interdisciplinary effects of technical debt in companies with mechatronic products—a qualitative study,"Digitalization of products and production systems requires a fusion of mechatronic disciplines, where interfaces between mechanical, electrical, and software engineering are inevitable. The increasingly rapid pace of innovations in mechatronic systems triggers decisions being taken under time and cost pressure. At times, compromises in technical solutions are made, neglecting their long-term damage to the system. Technical debt (TD), a concept from software engineering, refers to short-term benefits that lead to long-term negative consequences, e.g., in the form of more difficult maintainability or evolvability. This also applies to mechatronic systems, yet the knowledge of TD characteristics and correlations in the interdisciplinary life cycle has only received little attention. This first comprehensive survey investigates TD in mechatronics systematically and across sectors. 50 experts, of whom 42% hold positions as department heads, from 21 renowned companies and 10 sectors in the German-speaking region supported this study with real scenarios where TD caused damage to their system. 94 informative TD incidents that were classified into twelve TD types were recorded, of which 2/3 have not yet been eliminated and posed a potential risk to the system. TD emerges most frequently in the first three stages of the life cycle, where the consequences rarely remain isolated at their source but are forwarded to later phases and disciplines in the life cycle. In contrast to the research focus in software engineering, the multi-domain analysis of mechatronic TD issues reveals that software engineers are most burdened by Requirements TD and Infrastructure TD in the interdisciplinary environment."
230,2021,A Systems Perspective on Technical Debt,"This paper explores applications of the Technical Debt metaphor, which originated in the agile software community, at a systems level. We present a summary of current understanding of the technical debt concept and propose a broader application of the approach at a system level. The technical debt metaphor provides a method to identify cases when design or implementation decisions are being made for expediency and assess their long term impact on productivity and risk. In addition, technical debt management offers a logical approach to tracking expedient decisions and determining when it makes sense to carry the debt and when it's better to pay it off by updating designed and retrofitting units. In this paper, we describe various kinds of technical debt that may be present in a system baseline and consider how the presence of debt impacts further evolution of the system. Types of debt include architectural debt, configuration debt, testing debt and deprecation debt among others. We also present use case studies that illustrate how technical debt assessment and management can have a positive impact on system realization. Cases include moving a baseline from R&D to operations, reusing a baseline in a new context, and planning a technical refresh. We discuss methods of managing technical debt in a baseline including identification, quantification, tracking and payoff."
229,2021,Refactoring Techniques for Improving Software Quality: Practitioners’ Perspectives,"Refactoring is a critical task in software maintenance and is commonly applied to improve system design or to cope with design defects. There are 68 different types of refactoring techniques and each technique has a particular purpose and effect. However, most prior studies have selected refactoring techniques based on their common use in academic research without obtaining evidence from the software industry. This is a shortcoming that points to the existence of a clear gap between academic research and the corresponding industry practices. Therefore, to bridge this gap, this study identified the most frequently used refactoring techniques, the commonly used programming language, and methods of applying refactoring techniques in the current practices of software refactoring among software practitioners in the industry, by using an online survey. The findings from the survey revealed the most used refactoring techniques, programming language, and the methods of applying the refactoring techniques. This study contributes toward the improvement of software development practices by adding empirical evidence on software refactoring used by software developers. The findings would be beneficial for researchers to develop reference models and software tools to guide the practitioners in using these refactoring techniques based on their effect on software quality attributes to improve the quality of the software systems as a whole."
228,2021,The influence of cognitive biases on architectural technical debt,"Cognitive biases exert a significant influence on human thinking and decision-making. In order to identify how they influence the occurrence of architectural technical debt, a series of semi-structured interviews with software architects was performed. The results show which classes of architectural technical debt originate from cognitive biases, and reveal the antecedents of technical debt items (classes) through biases. This way, we analysed how and when cognitive biases lead to the creation of technical debt. We also identified a set of debiasing techniques that can be used in order to prevent the negative influence of cognitive biases. The observations of the role of organisational culture in the avoidance of inadvertent technical debt throw a new light on that issue."
227,2021,ATDx: A tool for providing a data-driven overview of architectural technical debt in software-intensive systems,"Architectural technical debt (ATD) in software-intensive systems is mostly invisible to software developers, can be widespread throughout entire code-bases, and its remediation cost is often steep. In recent years, numerous approaches have been proposed to identify, keep track, and ultimately manage ATD. The variety of approaches available opens a new problem, namely how to gain an encompassing overview of the ATD identified in a software-intensive system. With this paper we make available the ATDx tool, an implementation of ATDx written in Python, designed in a plug-in fashion. ATDx is an approach designed to provide a data-driven, intuitive, and actionable overview of the ATD present in a portfolio of software projects. ATDx is based on third-party source code analysis tools, architectural issue severity calculation via clustering, and aggregation of measurements into different architectural technical debt dimensions. The ATDx tool allows users to automatically run the ATDx analysis, generate reports containing the ATDx analysis results, and is integrated with GitHub. In addition to the tool, we provide two already implemented plugins, allowing users to run the ATDx tool out-of-the-box. GitHub repository: https://github.com/S2-group/ATDx Video: https://youtu.be/ULT9fgxuB7E"
226,2021,Reducing Incidents in Microservices by Repaying Architectural Technical Debt,"Architectural technical debt (ATD) may create a substantial extra effort in software development, which is called interest. There is little evidence about whether repaying ATD in microservices reduces such interest. Objectives: We wanted to conduct a first study on investigating the effect of removing ATD on the occurrence of incidents in a microservices architecture. Method: We conducted a quantitative and qualitative case study of a project with approximately 1000 microservices in a large, international financing services company. We measured and compared the number of software incidents of different categories before and after repaying ATD. Results: The total number of incidents was reduced by 84%, and the numbers of critical- and high-priority incidents were both reduced by approximately 90% after the architectural refactoring. The number of incidents in the architecture with the ATD was mainly constant over time, but we observed a slight increase of low priority incidents related to inaccessibility and the environment in the architecture without the ATD. Conclusion: This study shows evidence that refactoring ATDs, such as lack of communication standards, poor management of dead-letter queues, and the use of inadequate technologies in microservices, reduces the number of critical- and high-priority incidents and, thus, part of its interest, although some low priority incidents may increase."
222,2021,Impact of Opportunistic Reuse Practices to Technical Debt,"Technical debt (TD) has been recognized as an important quality problem for both software architecture and code. The evolution of TD techniques over the past years has led to a number of research and commercial tools. In addition, the increasing trend of opportunistic reuse (as opposed to systematic reuse), where developers reuse code assets in popular repositories, is changing the way components are selected and integrated into existing systems. However, reusing software opportunistically can lead to a loss of quality and induce TD, especially when the architecture is changed in the process. However, to the best of our knowledge, no studies have investigated the impact of opportunistic reuse in TD. In this paper, we carry out an exploratory study to investigate to what extent reusing components opportunistically negatively affects the quality of systems. We use one commercial and one research tool to analyze the TD ratios of three case systems, before and after opportunistically extending them with open-source software."
217,2021,"Technical Debt Prioritization: Taxonomy, Methods Results, and Practical Characteristics","Technical debt is the metaphor for shortcuts in software development that bring short-term benefits, but long-term consequences hinder the process of maintaining and developing software. It is important to manage these technical debt items, as not all of them need to be paid. Having a list of prioritized debts is an essential step in decision-making in the management process. This work aims at finding technical debt prioritization methods, providing a classification of them. That is, methods to identify whether and when a technical debt should be paid off. We performed a systematic mapping review to find and analyze the main papers of the area, covering the main bases. We selected 112 studies, resulting in 51 unique papers. We classified the methods in a two-level taxonomy containing 10 categories according to their different possible outcomes. In addition, we have identified three methods results: boolean, category and ordered list. Finally, we have also identified practical technical characteristics and requirements for a method to prioritize technical debt items in real projects. Although several methods have been found in literature, none of them are adaptive to the context and are language-independent, nor cover several technical debt types. Moreover, there is a clear lack of tools to use them. So, in conclusion, the research on technical debt prioritization is still wide open. From this study, a combination of the techniques used in these methods can be tested and automated to assist in the decision-making process on which debts should be paid."
223,2021,Building and evaluating a theory of architectural technical debt in software-intensive systems,"Abstract
Architectural technical debt in software-intensive systems is a metaphor used to describe the “big” design decisions (e.g., choices regarding structure, frameworks, technologies, languages, etc.) that, while being suitable or even optimal when made, significantly hinder progress in the future. While other types of debt, such as code-level technical debt, can be readily detected by static analyzers, and often be refactored with minimal or only incremental efforts, architectural debt is hard to be identified, of wide-ranging remediation cost, daunting, and often avoided.

In this study, we aim at developing a better understanding of how software development organizations conceptualize architectural debt, and how they deal with it. In order to do so, in this investigation we apply a mixed empirical method, constituted by a grounded theory study followed by focus groups. With the grounded theory method we construct a theory on architectural technical debt by eliciting qualitative data from software architects and senior technical staff from a wide range of heterogeneous software development organizations. We applied the focus group method to evaluate the emerging theory and refine it according to the new data collected.

The result of the study, i.e., a theory emerging from the gathered data, constitutes an encompassing conceptual model of architectural technical debt, identifying and relating concepts such as its symptoms, causes, consequences, management strategies, and communication problems. From the conducted focus groups, we assessed that the theory adheres to the four evaluation criteria of classic grounded theory, i.e., the theory fits its underlying data, is able to work, has relevance, and is modifiable as new data appears.

By grounding the findings in empirical evidence, the theory provides researchers and practitioners with novel knowledge on the crucial factors of architectural technical debt experienced in industrial contexts."
231,2021,Architectural design decisions that incur technical debt—An industrial case study,"Context: During software development, some architectural design decisions incur technical debt, either deliberately or inadvertently. These have serious impact on the quality of a software system, and can cost significant time and effort to be changed. While current research efforts have explored general concepts of architectural design decisions and technical debt separately, debt-incurring architectural design decisions have not been specifically explored in practice. Objective: In this case study, we explore debt-incurring architectural design decisions (DADDs) in practice. Specifically, we explore the main types of DADDs, why and how they are incurred in a software system, and how practitioners deal with these types of design decisions. Method: We performed interviews and a focus group with practitioners working in embedded and enterprise software companies, discussing their concrete experience with such architectural design decisions. Results: We provide the following contributions: 1) A categorization for the types of DADDs, which extend a current ontology on architectural design decisions. 2) A process on how deliberate DADDs are made in practice. 3) A conceptual model which shows the relationships between the causes and triggers of inadvertent DADDs. 4) The main factors that influence the way of dealing with DADDs."
221,2021,"A systematic literature review on technical debt prioritization: Strategies, processes, factors, and tools","Background
Software companies need to manage and refactor Technical Debt issues. Therefore, it is necessary to understand if and when refactoring of Technical Debt should be prioritized with respect to developing features or fixing bugs.

Objective
The goal of this study is to investigate the existing body of knowledge in software engineering to understand what Technical Debt prioritization approaches have been proposed in research and industry.

Method
We conducted a Systematic Literature Review of 557 unique papers published until 2020, following a consolidated methodology applied in software engineering. We included 44 primary studies.

Results
Different approaches have been proposed for Technical Debt prioritization, all having different goals and proposing optimization regarding different criteria. The proposed measures capture only a small part of the plethora of factors used to prioritize Technical Debt qualitatively in practice. We present an impact map of such factors. However, there is a lack of empirical and validated set of tools.

Conclusion
We observed that Technical Debt prioritization research is preliminary and there is no consensus on what the important factors are and how to measure them. Consequently, we cannot consider current research conclusive. In this paper, we therefore outline different directions for necessary future investigations.

"
220,2021,The Need for Holistic Technical Debt Management across the Value Stream: Lessons Learnt and Open Challenges,"The long lifetime and the evolving nature of industrial products make them subject to technical debt at different levels. Despite multiple years of research on technical debt management, our industrial experience shows that introducing systematic technical debt management in a large-scale company is very challenging. To identify the challenges, we provide a conceptual framework for holistic debt management across the product development value stream, which takes multiple categories of debt and their interplays into account. We use this framework to identify multiple challenges that are still open to be explored by the research community. Due to the practical nature of technical debt management, we believe this paper can guide the research community on the needs of industry for the effective application of technical debt management in practice."
219,2021,Technical debt payment and prevention through the lenses of software architects,"Context: Architectural decisions are considered one of the most common sources of technical debt (TD). Thus, it is necessary to understand how TD is perceived by software architects, particularly, the practices supporting the elimination of debt items from projects, and the practices used to reduce the chances of TD occurrence. Objective: This paper investigates the most commonly used practices to pay off TD and to prevent debt occurrence in software projects from the architect’s point of view. Method: We used the available data from InsighTD, which is a globally distributed family of industrial surveys on the causes, effects, and management of TD. We analyze responses from a corpus of 72 software architects from Brazil, Chile, Colombia, and the United States. Results: Results showed that refactoring (30.2%) was the main practice related to TD payment, followed by design improvements (14.0%). Refactoring, design improvements, and test improvements are the most cited payment practices among cases of code, design and test debt. Concerning the TD preventive practices, we find that having a well-defined architecture and design is the most cited practice (13.6%), followed by having a well-defined scope and requirements. This last practice is the most cited one for expert software architects. Finally, when comparing preventive practices among the three major roles derived from the survey (software architects, engineer roles, and management roles), we found that none of the roles shared the most cited practice, meaning that each role had its worries and focus on different strategies to reduce TD’s presence in the software. Conclusion: The lists of TD payment and prevention practices can guide software teams by having a catalog of practices to keep debt controlled or reduced."
225,2021,Architectural Technical Debt: Identification and Management,
236,2021,Technical Debt Guild: When experience and engagement improve Technical Debt Management,"Efficient Technical Debt Management (TDM) requires specialized guidance so that decisions taken are oriented to add value to the business. Because it is a complex problem that involves several variables, TDM requires a systemic look that considers professionals' experiences from different specialties. Guilds have been a means technology companies using the Spotify methodology have found to unite specialized professionals around a common interest. This paper presents the experience in implementing a guild to support TDM's source code activities in a software development organization, using the action research method. The project lasted two years, and approximately 100 developers were involved in updating about 63,300 source-code files. The actions resulting from the TDM guild's efforts impacted the company's culture by introducing new development practices and standards. Besides, they positively influenced the quality of the artifact delivered by the developers. This study shows that, as the company acquires maturity in TDM, it increases the need for professionals dedicated to TDM's activities."
224,2021,Architectural Technical Debt of Multiagent Systems Development Platforms,"Technical debt is candidate to be the next buzzword in software engineering, and the number of studies evaluating the technical debt of software projects is increasing. A particular and dangerous type of debt is the architectural debt, i.e., the consequences of sub-optimal design decisions. Currently, there are no studies about the evaluation of architectural debt in MultiAgent Systems (MAS) and platforms. Hence, in this paper we propose the analysis of four well-known MAS development platforms, with the aim of evaluating their architectural debt and open the discussion in this field. We exploit a tool, named Arcan, developed for architectural smell detection and for the computation of an architectural debt index. The results show that MAS development platforms are subjected to architectural debt, and in particular to the presence of Cyclic Dependency smells. However, there is evidence that the minimum amount of debt is reached when developers report “bug fixes” and “Improvements"
235,2021,The temporality of technical debt introduction on new code and confounding factors,"Code Technical Debt (TD) is intentionally or unintentionally created when developers introduce inefficiencies in the codebase. This can be attributed to various reasons such as heavy workload, tight delivery schedule, or developers’ lack of experience. Since a software system grows mostly through the addition of new code, it is interesting to study how TD fluctuates along this process. Specifically, in this paper, we investigate: (a) the temporality of code TD introduction in new code, i.e., whether the introduction of TD is stable across the lifespan of the project, or if its evolution presents spikes; and (b) the relation of TD introduction to the development team’s workload in a given period, as well as to the experience of the development team. To answer these questions, we have performed a case study on 47 open-source projects from two well-known ecosystems (Apache and Eclipse) as well as additional isolated projects from GitHub (not selected from a specific ecosystem) and inspected the number of TD issues introduced in 6-month sliding temporal windows. The results of the study suggested that: (a) overall, the number of TD issues introduced through new code is a stable measure, although it presents spikes; and (b) the number of commits performed, as well as developers’ experience are not strongly correlated to the number of introduced TD issues."
234,2021,The perception of Architectural Smells in industrial practice,"Architectural technical debt (TD) is the most significant type of TD in industrial practice. Our goals in this study were to better understand the phenomenon of architectural smells, help practitioners better manage them, and offer relevant support to researchers."
218,2021,Technical debt tools: a systematic mapping study,"Context: The concept of technical debt is a metaphor that contextualizes problems faced during software evolution that reflect technical compromises in tasks that are not carried out adequately during their development - they can yield short-term benefit to the project in terms of increased productivity and lower cost, but that may have to be paid off with interest later. Objective: This work investigates the current state of the art of technical debt tools by identifying which activities, functionalities and kind of technical debt are handled by existing tools that support the technical debt management in software projects. Method: A systematic mapping study is performed to identify and analyze available tools for managing technical debt based on a set of five research questions. Results: The work contributes with (i) a systematic mappping of current research on the field, (ii) a highlight of the most referenced tools, their main characteristics, their supported technical debt types and activities, and (iii) a discussion of emerging findings and implications for future research. Conclusions: Our study identified 50 TD tools where 42 of them are new tools, and 8 tools extend an existing one. Most of the tools address technical debt related to code, design, and/or architecture artifacts. Besides, the different TD management activities received different levels of attention. For example, TD identification is supported by 80% of the tools, whereas 30% of them handle the TD documentation activity. Tools that deal with TD identification and measurement activities are still predominant. However, we observed that recent tools focusing on TD prevention, replacement, and prioritization activities represent emergent research trends."
247,2021,Using Version Control and Issue Tickets to detect Code Debt and Economical Cost,"Despite the fact that there are numerous classifications of technical debt based on various criteria, Code Debt or code smells is a category that appears in the majority of current research. One of the primary causes of code debt is the urgency to deliver software quickly, as well as bad coding practices. Among many approaches, static code analysis has received the most attention in studies to detect code-smell/code debt. However, most of them examine the same programming language, although today’s software company utilizes many development stacks with various languages and tools. This problem can be resolved by detecting code debt with Issue/Ticket cards. This paper presents a method for detecting code debt leveraging natural language processing on issue tickets. It also proposes a method for calculating the average amount of time that a code debt was present in the software. This method is implemented utilizing git mining."
246,2021,The Technical Debt Density Over Multiple Releases and the Refactoring Story,"Do developers postpone fixing Technical Debt (TD) in software systems? TD is a metaphor that refers to short-term decisions in software development that may affect the cost of the software development life cycle. The bad smell is an imperfect solution in the software system that negatively impacts the internal software quality and maintainability. In this paper, we will study five open-source software projects (OSSPs) that have several releases and also estimate the numbers of architecture smells (ASs), design smells (DSs), and code smells (CSs) for every release. Designite will be used to detect smells. We describe a case study conducted to explore the following: (1) What is the average smells density for architecture, design, and code smells in an OSSP? (2) Does the density of each smell type increase over multiple releases? (3) What percentage of each smell-type density is eliminated by refactoring? We collected around 2 million LOC from five OSSPs that have multiple releases from the GitHub repository to statistically analyze the software concerning the smells as indicators of TD. We find 36% of Architecture Technical Debt (ATD) is Cyclic Dependency, while 33% of Design Debt (DD) is Cyclically-dependent Modularization. More than 70% of Code Debt (CD) is Magic Number. Even though the developers do refactoring between releases, the TD density in general increases. On average, by refactoring, developers remove around 48%, 16%, and 22% from the introduced ATD, DD, and CD from their next release, respectively."
244,2021,Towards a comprehensive self-admitted technical debt extraction technique from source code comments,"Identifying Technical Debt (TD) within Software Development Projects (SDP) is a growing research interest as it has the potential to save software developers’ effort in maintenance tasks. Although there are ten types of TD, there is a lack of automatic techniques to extract them through static nor dynamic analysis. This paper proposes a self-admitted TD extraction framework to extract TD from software’s comments and classify them comprehensively through a Parts-of-Speech technique. A public TD dataset is used to evaluate the proposed framework. Results show that the proposed technique was able to increase the classification of build, architectural, versioning, and infrastructure TD by 16%."
243,2021,Evaluating the Architectural Debt of IoT Projects,"We observed a great and increasing interest in the last few years towards the evaluation of technical debt of software projects, in particular in the direction of code and architectural debt evaluation. This kind of analysis has not yet been performed for IoT projects. Hence, in this paper we start this exploration through the analysis of four Open Source IoT projects. We focus our attention on architectural debt and we exploit a tool, called Arcan, developed for architectural smell detection and for the computation of an architectural debt index. The results show that also IoT projects are subjected to architectural debt, and in particular to the presence of Cyclic Dependency and Unstable Dependency smells. However, there is evidence that the continuous refactoring of the code helps in avoiding the increase of debt, hence also developers of IoT projects should schedule periodical clean-ups of their code."
245,2021,Supporting Sustainability and Technical Debt-Driven Design Decisions in Software Architectures,"Degraded software usually incurs higher energy consumption, therefore suboptimal decisions in software architectures may lead to higher technical debt and less sustainable software products. There are metrics and tools to calculate technical debt and energy consumption of software, but it is required to provide mechanisms to store their relationship and how they change depending on the design decisions. In addition, there are different models for calculating the same metric and different metrics to measure technical debt and power consumption, and software engineers require selecting the most suitable model and metric depending on the software product context. This work presents a metamodel called ARCMEL to provide the required base of knowledge for supporting green-aware design decisions and to flexibly configure and select metrics and their models. ARCMEL has been implemented as part of the ARCMEL SCAT tool. Its validation is also presented in terms of completeness and flexibility."
241,2021,Preventing Technical Debt by Technical Debt Aware Project Management,"Technical Debts (TD) are problems of the internal software quality. They are often contracted due to tight project deadlines, for example quick fixes and workarounds, and can make future changes more costly or impossible. TD prevention should be more important than TD repayment, because subsequent refactoring and reengineering is usually more expensive than building the right solution from the beginning. While there are numerous works on TD repayment, solutions for TD prevention are understudied. This paper evaluates a framework that focuses on both TD prevention and TD repayment. It was developed by and applied in an IT unit of a publishing house. The unique contribution of this framework is the integration of TD management into project management. The evaluation was carried out by a study based on ticket statistics and a structured survey with participants from the observed IT unit and a comparison unit. The evaluation shows that the adoption of this framework leads to a raised awareness for the contraction of TD. This results in benefits like more rational discussions and decisions, TD prevention and timelier repayment of TD tickets."
240,2021,How Experience Impacts Practitioners' Perception of Causes and Effects of Technical Debt,"Context: The technical debt (TD) metaphor helps to conceptualize the pending issues and trade-offs made during software development. Knowing TD causes can support in defining preventive actions and having information about effects aids in the prioritization of TD payment. Goal: To investigate the impact of the experience level on how practitioners perceive the most likely causes that lead to TD and the effects of TD that have the highest impacts on software projects. Method: We approach this topic by surveying 227 practitioners. Results: While experienced software developers focus on human factors as TD causes and external quality attributes as TD effects, low experienced developers seem to concentrate on technical issues as causes and internal quality issues and increased project effort as effects. Missing any of these types of causes could lead a team to miss the identification of important TD, or miss opportunities to preempt TD. On the other hand, missing important effects could hamper effective planning or erode the effectiveness of decisions about prioritizing TD items. Conclusion: Having software development teams composed of practitioners with a homogeneous experience level can erode the team's ability to effectively manage TD."
239,2021,"Identifying architectural technical debt, principal, and interest in microservices: A multiple-case study","Background: Using a microservices architecture is a popular strategy for software organizations to deliver value to their customers fast and continuously. However, scientific knowledge on how to manage architectural debt in microservices is scarce. Objectives: In the context of microservices applications, this paper aims to identify architectural technical debts (ATDs), their costs, and their most common solutions. Method: We conducted an exploratory multiple case study by conducting 25 interviews with practitioners working with microservices in seven large companies. Results: We found 16 ATD issues, their negative impact (interest), and common solutions to repay each debt together with the related costs (principal). Two examples of critical ATD issues found were the use of shared databases that, if not properly planned, leads to potential breaks on services every time the database schema changes and bad API designs, which leads to coupling among teams. We identified ATDs occurring in different domains and stages of development and created a map of the relationships among those debts. Conclusion: The findings may guide organizations in developing microservices systems that better manage and avoid architectural debts."
238,2021,Technical Debt predictive model through Temporal Convolutional Network,"Technical debt is a metaphor that refers to all the consequences of poorly written code and trade-offs in development. Early technical debt diagnosis is important for software developers because it allows planning for software maintenance and improvement activities, such as refactoring, to prevent system degradation. Several studies have been conducted in the literature on the identification of the technical debt and its consequences, thanks to useful tools for identifying the problem within the source code. On the other hand, this work aims to explore a deep learning approach to predict the rise of technical debt in software code by leveraging the knowledge of changing quality metrics. For validation of the approach, a large dataset was built, related to four known Java software projects, with the collection of numerous class-level code quality metrics. The results obtained show the effectiveness of the proposed approach in predicting the development of Technical Debt within the source code. We obtained an F1 score of 0.99 for two of the chosen software systems and greater than 0.91 for the remaining two"
237,2021,How to get away with technical debt: An explorative multiple-case study on autonomous teams and technical debt management,"Technical debt (TD) is constantly accumulating throughout software development processes. In many autonomous teams this technical debt will damage and injure the process, prohibiting them from adding new functionalities to their products. Tech companies must therefore understand how they can manage TD to avoid getting stuck fixing bad code. In the research on technical debt management (TDM), there seems to be a lack of empirical studies that examine how TD is managed in autonomous teams. Some frameworks are developed with the purpose of investigating TDM but lack the empirical validation and reliability.
This study investigates how autonomous teams actively manage technical debt, by conducting a multiple-case study in a Norwegian fintech company. The teams are studied by utilizing the TDM framework, measuring autonomous teams’ degree of maturity within different TDM activities in order to understand their current state of practice and how to further improve these.
The study found that all autonomous teams practiced TDM, but to various extents. Some teams had structured processes, while others had no clear strategies. Most of the teams were ranked with what the framework call “received level of maturity”, and conducted TDM activities occasionally based on their current needs. The study also found challenges related to the TDM frameworks maturity levels relation to TDM success, and identified that TDM activities ranked as highly mature did not necessarily translate into higher TDM success.
The study identified a need for the TDM framework to be further empirically tested and iterated on for it to work as a an accurate tool for understanding and improving autonomous teams’ TDM processes."
242,2021,Exploring the Tensions Between Management of Architectural Debt and Digital Innovation: The Case of a Financial Organization,"The metaphor Technical Debt describes the consequences of taking shortcuts in the software development process for short-term benefit, at the expense of higher maintenance in the future. Every large software system contains Technical Debt in some way or another, the dicult question is to know when, where, and how to repay the debt. To answer this we conducted three main steps. A literature study on how to identify, measure, and manage Technical Debt (i), interviews (ii), and finding key software metrics based on the Goal-Question-Metric paradigm to build a Technical Debt Model with a visualisation dashboard (iii). This was used for a case study at an organisation where files from two projects were analysed and the model was evaluated by comparing the results with opinions from developers who created the system. The final model used 8 metrics as input and had a total success rate of 80% when comparing the model’s ranking with mutual opinion of the developers. The dashboard was seen to be a useful tool for discussion and a quick way to identify areas in the code with Technical Debt. It was also discovered that measuring Technical Debt with only software metrics is a hard to impossible task, and many sources of information must be used in conjunction. To circumvent this, an implementation model for the organisation using several information channels together with the dashboard was created"
251,2022,Exploiting gated graph neural network for detecting and explaining self-admitted technical debts,"Self-admitted technical debt (SATD) refers to a specific type of technical debt that is introduced intentionally in the software development and maintenance processes. SATD enables practitioners to take some temporary solutions instead of making comprehensive decisions, which will lead to the high complexity of the software. However, most existing studies relied on manual methods for detecting SATDs. A recent study proposed a method HATD that used a hybrid attention-based method to automatically detect SATDs and it achieved the state-of-the-art performance. However, HATD mainly focused on the locality of the comment instances and lacked of the relationship between long-distance and discontinuous comment instances. To address such an issue, in this work, we propose a novel approach named GGSATD. Specifically, GGSATD first builds the graph for comment instances and then employs the gated graph neural network to iteratively update node representation. The global representation can be obtained by the soft attention mechanism and pooling operation. Experiments on 10 projects show that our GGSATD method obtains promising performance against five baseline methods in both within-project and cross-project scenarios. Extended experiments on seven real-world projects illustrate the effectiveness of our GGSATD method."
260,2022,On the relation between architectural smells and source code changes,"Although architectural smells are one of the most studied type of architectural technical debt, their impact on maintenance effort has not been thoroughly investigated. Studying this impact would help to understand how much technical debt interest is being paid due to the existence of architecture smells and how this interest can be calculated. This work is a first attempt to address this issue by investigating the relation between architecture smells and source code changes. Specifically, we study whether the frequency and size of changes are correlated with the presence of a selected set of architectural smells. We detect architectural smells using the Arcan tool, which detects architectural smells by building a dependency graph of the system analyzed and then looking for the typical structures of the architectural smells. The findings, based on a case study of 31 open-source Java systems, show that 87% of the analyzed commits present more changes in artifacts with at least one smell, and the likelihood of changing increases with the number of smells. Moreover, there is also evidence to confirm that change frequency increases after the introduction of a smell and that the size of changes is also larger in smelly artifacts. These findings hold true especially in Medium–Large and Large artifacts."
248,2022,"Prevalence, common causes and effects of technical debt: Results from a family of surveys with the IT industry","Context:
The technical debt (TD) metaphor describes actions made during various stages of software development that lead to a more costly future regarding system maintenance and evolution. According to recent studies, on average 25% of development effort is spent, i.e. wasted, on TD caused issues in software development organizations. However, further research is needed to investigate the relations between various software development activities and TD.

Objective:
The objective of this study is twofold. First, to get empirical insight on the understanding and the use of the TD concept in the IT industry. Second, to contribute towards precise conceptualization of the TD concept through analysis of causes and effects.

Method:
In order to address the research objective a family of surveys was designed as a part of an international initiative that congregates researchers from 12 countries—InsighTD. At country level, national teams ran survey replications with industry practitioners from the respective countries.

Results:
In total 653 valid responses were collected from 6 countries. Regarding the prevalence of the TD concept 22% of practitioners have only theoretical knowledge about it, and 47% have some practical experiences with TD identification or management. Further analysis indicated that senior practitioners who work in larger organizations, larger teams, and on larger systems are more likely to be experienced with TD management. Time pressure or deadlinewas the single most cited cause of TD. Regarding the effects of TD: delivery delay, low maintainability, and rework were the most cited.

Conclusion:
InsighTD is the first family of surveys on technical debt in software engineering. It provided a methodological framework that allowed multiple replication teams to conduct research activities and to contribute to a single dataset. Future work will focus on more specific aspects of TD management."
249,2022,DebtFree: Minimizing Labeling Cost in Self-Admitted Technical Debt Identification using Semi-Supervised Learning,"Keeping track of and managing Self-Admitted Technical Debts (SATDs) is important for maintaining a healthy software project. Current active-learning SATD recognition tool involves manual inspection of 24% of the test comments on average to reach 90% of the recall. Among all the test comments, about 5% are SATDs. The human experts are then required to read almost a quintuple of the SATD comments which indicates the inefficiency of the tool. Plus, human experts are still prone to error: 95% of the false-positive labels from previous work were actually true positives.
To solve the above problems, we propose DebtFree, a two-mode framework based on unsupervised learning for identifying SATDs. In mode1, when the existing training data is unlabeled, DebtFree starts with an unsupervised learner to automatically pseudo-label the programming comments in the training data. In contrast, in mode2 where labels are available with the corresponding training data, DebtFree starts with a pre-processor that identifies the highly prone SATDs from the test dataset. Then, our machine learning model is employed to assist human experts in manually identifying the remaining SATDs. Our experiments on 10 software projects show that both models yield a statistically significant improvement in effectiveness over the state-of-the-art automated and semi-automated models. Specifically, DebtFree can reduce the labeling effort by 99% in mode1 (unlabeled training data), and up to 63% in mode2 (labeled training data) while improving the current active learner's F1 relatively to almost 100%."
250,2022,Empirical evaluation of an architectural technical debt index in the context of the Apache and ONAP ecosystems,"Background Architectural Technical Debt (ATD) in a software-intensive system denotes architectural design choices which, while being suitable or even optimal when adopted, lower the maintainability and evolvability of the system in the long term, hindering future development activities. Despite the growing research interest in ATD, how to gain an informative and encompassing viewpoint of the ATD present in a software-intensive system is still an open problem. Objective In this study, we evaluate ATDx, a data-driven approach providing an overview of the ATD present in a software-intensive system. The approach, based on the analysis of a software portfolio, calculates severity levels of architectural rule violations via a clustering algorithm, and aggregates results into different ATD dimensions. Method To evaluate ATDx, we implement an instance of the approach based on SonarQube, and run the analysis on the Apache and ONAP ecosystems. The analysis results are then shared with the portfolio contributors, who are invited to participate in an online survey designed to evaluate the representativeness and actionability of the approach. Results The survey results confirm the representativeness of the ATDx, in terms of both the ATDx analysis results and the used architectural technical debt dimensions. Results also showed the actionability of the approach, although to a lower extent when compared to the ATDx representativeness, with usage scenarios including refactoring, code review, communication, and ATD evolution analysis. Conclusions With ATDx, we strive for the establishment of a sound, comprehensive, and intuitive architectural view of the ATD identifiable via source code analysis. The collected results are promising, and display both the representativeness and actionability of the approach. As future work, we plan to consolidate the approach via further empirical experimentation, by considering other development contexts (e.g., proprietary portfolios and other source code analysis tools), and enhancing the ATDx report capabilities."
252,2022,Technical debt resulting from architectural degradation and code smells: a systematic mapping study,"Poor design choices, bad coding practices, or the need to produce software quickly can stand behind technical debt. Unfortunately, manually identifying and managing technical debt gets more difficult as the software matures. Recent research offers various techniques to automate the process of detecting and managing technical debt to address these challenges. This manuscript presents a mapping study of the many aspects of technical debt that have been discovered in this field of study. This includes looking at the various forms of technical debt, as well as detection methods, the financial implications, and mitigation strategies. The findings and outcomes of this study are applicable to a wide range of software development life-cycle decisions."
255,2022,Characterizing the architectural erosion metrics: A systematic mapping study,"Software architecture is crucial in determining success or failure in a variety of software development and design fields. Typically, as a system evolves, software architecture deteriorates. This phenomenon is known as architectural erosion. Several studies have addressed architectural erosion based on different solutions. As a result, the metrics technique is the most prevalent solution for architectural erosion. Nevertheless, a comprehensive description of architectural erosion metrics remains unorganized and scattered. This work aims to conduct a systematic mapping to describe and analyze the architectural erosion metrics to provide an overview of erosion metrics and their current trends. Furthermore, no systematic attempts have been made on architectural erosion metrics. The final samples of this study were specified as a total of 43 included papers. Nearly 100 architectural erosion metrics were found. We proposed nine classifications to address architectural erosion challenges, based on adopted approaches in primary studies. The metrics of architectural erosion provide strong evidence for identifying decay and a rapid enabler factor for the adoption of numerous metrics mechanisms to address architectural erosion. The classification of metrics, which is the first of its kind, benefits researchers and practitioners. However, it can be concluded that various aspects are still ambiguous and require further research on architectural erosion measures."
254,2022,Accumulation and prioritization of Architectural Debt in three companies migrating to microservices,"Many companies migrate to microservices because they help deliver value to customers quickly and continuously. However, like any architectural style, microservices are prone to architectural technical debt (ATD), which can be costly if the debts are not timely identified, avoided, or removed. During the early stages of migration, microservice-specific ATDs may accumulate. For example, practitioners may decide to continue using poorly defined APIs in microservices while attempting to maintain compatibility with old functionalities. The riskiest ATDs must be prioritized. Nevertheless, there is limited research regarding the prioritization of ATDs in companies migrating to microservices. This study aims to identify, during migration, which microservice-specific ATDs occur, are the most severe, and are the most challenging to solve. In addition, we propose a way to prioritize these debts. We conducted a multiple exploratory case study of three large companies that were early in the migration process to microservices. We interviewed 47 practitioners with several roles to identify the debts in their contexts.We report the ATDs detected during migration, the ATDs that practitioners estimate to occur in the future, and the ATDs that practitioners report as difficult to solve. We discuss the results in the context of the companies involved in this study. In addition, we used a risk assessment approach to propose a way for prioritizing ATDs. Practitioners from other organizations and researchers may use this approach to provide rankings to help identify and prioritize which ATDs should be avoided or solved in their contexts."
256,2022,Automatic Detection and Analysis of Technical Debts in Peer-Review Documentation of R Packages,"Technical debt (TD) is a metaphor for code-related problems that arise as a result of prioritizing speedy delivery over perfect code. Given that the reduction of TDs can have long-term positive impact in the software engineering life-cycle (SDLC), TDs are studied extensively in the literature. However, very few of the existing research focused on the technical debts of R programming language despite its popularity and usage. Recent research by Codabux et al. [21] finds that R packages can have 10 diverse TD types analyzing peer-review documentation. However, the findings are based on the manual analysis of a small sample of R package review comments. In this paper, we develop a suite of Machine Learning (ML) classifiers to detect the 10 TDs automatically. The best performing classifier is based on the deep ML model BERT, which achieves F1-scores of 0.71 - 0.91. We then apply the trained BERT models on all available peer-review issue comments from two platforms, rOpenSci and BioConductor (13.5K review comments coming from a total of 1297 R packages). We conduct an empirical study on the prevalence and evolution of 10 TDs in the two R platforms. We discovered documentation debt is the most prevalent among all types of TD, and it is also expanding rapidly. We also find that R packages of generic platform (i.e. rOpenSci) are more prone to TD compared to domain-specific platform (i.e. BioConductor). Our empirical study findings can guide future improvements opportunities in R package documentation. Our ML models can be used to automatically monitor the prevalence and evolution of TDs in R package documentation."
257,2022,BARRIERS AND ENABLERS OF DIGITAL TRANSFORMATION: AN EXPLORATORY ANALYSIS OF DIGITAL DEBT AND DEVOPS,"The rapid diffusion of digital technologies, combined with a large amount of data generated by interactions between users and organizations, has led to the reinvention of the way in which markets develop and improve their business models. It is not uncommon to hear that every company is a technology company. However, this status cannot be achieved quickly as it requires the development of organizational resources and capabilities, in addition to a new digital mindset to produce a strategy capable of overcoming its internal barriers and leveraging the enablers of this transformation. Incumbent and established organizations present barriers to their digital transformation when facing constraints from their legacy systems with their needs for modernization or even replacement. Furthermore, the pressure to deliver new business value propositions forces sub-optimal technical decisions that take a toll on product quality and the flexibility of the solutions. This accumulation of deficiencies in the organization's technological portfolio promotes digital debt with its customers, undermining its value proposition. In view of this, new philosophies, such as DevOps, have been emerging to ensure a cycle of continuous improvement, increase productivity, address product quality issues, change the culture, and adopt new approaches to deliver digital products. This exploratory study presents evidence that digital debt and DevOps act, respectively, as a barrier and enabler of the organization's digital maturity, promoting a discussion about their prioritization in the organization's digital business strategy. A proposal for deepening the academic field is also presented."
258,2022,Understanding software architecture erosion: A systematic mapping study,"Architecture erosion (AEr) can adversely affect software development and has received significant attention in the last decade. However, there is an absence of a comprehensive understanding of the state of research about the reasons and consequences of AEr, and the countermeasures to address AEr. This work aims at systematically investigating, identifying, and analyzing the reasons, consequences, and ways of detecting and handling AEr. With 73 studies included, the main results are as follows: (1) AEr manifests not only through architectural violations and structural issues but also causing problems in software quality and during software evolution; (2) non-technical reasons that cause AEr should receive the same attention as technical reasons, and practitioners should raise awareness of the grave consequences of AEr, thereby taking actions to tackle AEr-related issues; (3) a spectrum of approaches, tools, and measures has been proposed and employed to detect and tackle AEr; and (4) three categories of difficulties and five categories of lessons learned on tackling AEr were identified. The results can provide researchers a comprehensive understanding of AEr and help practitioners handle AEr and improve the sustainability of their architecture. More empirical studies are required to investigate the practices of detecting and addressing AEr in industrial settings."
259,2022,On the evolution and impact of Architectural Smells--An industrial case study,"Architectural smells (AS) are notorious for their long-term impact on the Maintainability and Evolvability of software systems. The majority of research work has investigated this topic by mining software repositories of open source Java systems, making it hard to generalise and apply them to an industrial context and other programming languages. To address this research gap, we conducted an embedded multiple-case case study, in collaboration with a large industry partner, to study how AS evolve in industrial embedded systems. We detect and track AS in 9 C/C++ projects with over 30 releases for each project that span over two years of development, with over 20 millions lines of code in the last release only. In addition to these quantitative results, we also interview 12 among the developers and architects working on these projects, collecting over six hours of qualitative data about the usefulness of AS analysis and the issues they experienced while maintaining and evolving artefacts affected by AS. Our quantitative findings show how individual smell instances evolve over time, how long they typically survive within the system, how they overlap with instances of other smell types, and finally what the introduction order of smell types is when they overlap. Our qualitative findings, instead, provide insights on the effects of AS on the long-term maintainability and evolvability of the system, supported by several excerpts from our interviews. Practitioners also mention what parts of the AS analysis actually provide actionable insights that they can use to plan refactoring activities."
253,2022,Relationships between software architecture and source code in practice: An exploratory survey and interview,"Context
Software Architecture (SA) and Source Code (SC) are two intertwined artefacts that represent the interdependent design decisions made at different levels of abstractions - High-Level (HL) and Low-Level (LL). An understanding of the relationships between SA and SC is expected to bridge the gap between SA and SC for supporting maintenance and evolution of software systems.

Objective
We aimed at exploring practitioners’ understanding about the relationships between SA and SC.

Method
We used a mixed-method that combines an online survey with 87 respondents and an interview with 8 participants to collect the views of practitioners from 37 countries about the relationships between SA and SC.

Results
Our results reveal that: practitioners mainly discuss five features of relationships between SA and SC; a few practitioners have adopted dedicated approaches and tools in the literature for identifying and analyzing the relationships between SA and SC despite recognizing the importance of such information for improving a system's quality attributes, especially maintainability and reliability. It is felt that cost and effort are the major impediments that prevent practitioners from identifying, analyzing, and using the relationships between SA and SC.

Conclusions
The results have empirically identified five features of relationships between SA and SC reported in the literature from the perspective of practitioners and a systematic framework to manage the five features of relationships should be developed with dedicated approaches and tools considering the cost and benefit of maintaining the relationships."
2,2022,An Empirical Study of the Extent and Causes of Technical Debt in Public Organizations Software Systems,"Because of short time to market for software systems, suboptimal design and implementation choices are sometimes made by software teams. Technical Debt (TD) is the term used to describe software quality flaws that are caused by time-saving shortcuts. Previous research has focused on the identification, causes, and management of TD. However, most of previous studies on TD have been informed by private and open source software projects, lacking insights from the public sector. Researchers have argued that software systems in the public sector are different from software systems in the private sector and open source projects, because organizations in the public sector are subjected to specific restrictions and requirements. Thus, TD causes, challenges, and the strategies to manage TD might differ between the public sector and the private sector and open source projects, which calls for the need to study TD in the public sector.To make a start in filling this gap, we studied 102 software systems and surveyed 73 practitioners from 13 public organizations in Tanzania, to understand the extent and causes of TD in the Tanzanian public sector. A substantial amount of TD was found in the studied systems. Architectural TD was the most accumulated type of TD, followed by Design TD and Code TD. Moreover, modularity violations and project management issues were found to be the leading causes of TD in software systems of the studied public organizations. We, thus, recommend the investigation of TD management strategies that are suitable for software systems in the public sector. From a public sector viewpoint, we contribute empirical insights to the literature on the extent, causes, and management of TD in software systems."
261,2022,A triple bottom-line typology of technical debt: Supporting decision-making in cross-functional teams,"Technical Debt (TD) is a widely discussed metaphor in IT practice focused on increased short-term benefit in exchange for long-term ‘debt’. While it is primarily individuals or groups inside IT departments who make the decisions to take on TD, we find that the effects of TD stretch across the entire organisation. Decisions to take on TD should therefore concern a wider group. However, business leaders have traditionally lacked awareness of the effects of what they perceive to be ‘technology decisions’. To facilitate TD as group-based decision-making, we review existing literature to develop a typology of the wider impacts of TD. The goal is to help technologists, non-technologists, and academics have a broader and shared understanding of TD and to facilitate more participatory and transparent technology-related decision making. We extend the typology to include a wider ‘outside in’ perspective and conclude by suggesting areas for further research."
